// =================================================================================
// --- DYNAMIC QUERY ENGINE FUNCTIONS ---
// =================================================================================

/**
 * Sets up the required sheets for the Dynamic Query Engine if they don't exist.
 * This function should be run manually once or called from an onOpen trigger.
 */
function setupQueryEngineSheets() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);

    // Setup QueryQueue Sheet
    let queueSheet = ss.getSheetByName("QueryQueue");
    if (!queueSheet) {
      queueSheet = ss.insertSheet("QueryQueue");
      const queueHeaders = ["QueryID", "SubmittedBy", "Status", "QueryJSON", "StartTime", "EndTime", "OutputSheetURL", "ErrorMessage"];
      queueSheet.appendRow(queueHeaders);
      queueSheet.getRange("A1:H1").setFontWeight("bold");
    }

    // Setup QueryLibrary Sheet
    let librarySheet = ss.getSheetByName("QueryLibrary");
    if (!librarySheet) {
      librarySheet = ss.insertSheet("QueryLibrary");
      const libraryHeaders = ["QueryName", "Description", "QueryJSON", "SubmittedBy"];
      librarySheet.appendRow(libraryHeaders);
      librarySheet.getRange("A1:D1").setFontWeight("bold");
    }

    return "Query Engine sheets are set up successfully.";
  } catch (e) {
    Logger.log(`Error in setupQueryEngineSheets: ${e.toString()}`);
    throw new Error("Could not set up Query Engine sheets.");
  }
}

/**
 * Submits a query to the asynchronous queue.
 * This is the entry point called from the frontend.
 */
function submitQueryToQueue(queryJSON) {
  try {
    setupQueryEngineSheets();

    const userEmail = Session.getActiveUser().getEmail();
    const queryId = `${new Date().getTime()}_${userEmail}`;

    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const queueSheet = ss.getSheetByName("QueryQueue");

    queueSheet.appendRow([
      queryId,
      userEmail,
      "Pending",
      queryJSON,
      new Date(), // StartTime
      "", // EndTime
      "", // OutputSheetURL
      ""  // ErrorMessage
    ]);

    // --- "Ignition" Logic ---
    const allTriggers = ScriptApp.getProjectTriggers();
    let triggerExists = false;
    for (const trigger of allTriggers) {
      if (trigger.getHandlerFunction() === 'runQueryEngineBatch') {
        triggerExists = true;
        break;
      }
    }

    if (!triggerExists) {
      ScriptApp.newTrigger('runQueryEngineBatch')
        .timeBased()
        .after(60 * 1000) // ~1 minute
        .create();
    }

    return {
      message: `Query submitted successfully with ID: ${queryId}. It will be processed shortly.`
    };

  } catch (e) {
    Logger.log(`Error in submitQueryToQueue: ${e.toString()}`);
    throw new Error("Could not submit query to the queue.");
  }
}

function runQueryEngineBatch() {
    const properties = PropertiesService.getScriptProperties();
    let queryId = properties.getProperty('currentQueryID');
    const startTime = new Date().getTime();
    const lock = LockService.getScriptLock();
    if (!lock.tryLock(10000)) {
        Logger.log("Could not acquire lock, another instance is likely running. Exiting.");
        return;
    }

    try {
        while (new Date().getTime() - startTime < 270000) { // Time-aware loop
            if (!queryId) {
                const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
                const queueSheet = ss.getSheetByName("QueryQueue");
                const data = queueSheet.getDataRange().getValues();
                const headers = data.shift();
                const statusCol = headers.indexOf("Status");
                const queryIdCol = headers.indexOf("QueryID");

                let pendingQueryRow = -1;
                for (let i = 0; i < data.length; i++) {
                    if (data[i][statusCol] === "Pending") {
                        pendingQueryRow = i + 2;
                        break;
                    }
                }

                if (pendingQueryRow === -1) {
                    Logger.log("No pending queries found. Engine is going to sleep.");
                    return; // Self-terminate
                }

                queryId = queueSheet.getRange(pendingQueryRow, queryIdCol + 1).getValue();
                queueSheet.getRange(pendingQueryRow, statusCol + 1).setValue("Running");
                properties.setProperty('currentQueryID', queryId);
                SpreadsheetApp.flush();
            }

            // Initialize or retrieve state
            let state = {};
            const stateJSON = properties.getProperty(`state_${queryId}`);
            if (stateJSON) {
                state = JSON.parse(stateJSON);
            } else {
                const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
                const queueSheet = ss.getSheetByName("QueryQueue");
                const data = queueSheet.getDataRange().getValues();
                const headers = data.shift();
                const queryJsonCol = headers.indexOf("QueryJSON");
                const queryIdCol = headers.indexOf("QueryID");
                let queryJSONString = "";
                let queryRowIndex = -1;

                for(let i=0; i < data.length; i++) {
                    if(data[i][queryIdCol] === queryId) {
                        queryJSONString = data[i][queryJsonCol];
                        queryRowIndex = i + 2;
                        break;
                    }
                }

                const outputSs = SpreadsheetApp.create(`QueryResult_${queryId}`);
                const outputUrl = outputSs.getUrl();
                const outputSheetId = outputSs.getId();

                const query = JSON.parse(queryJSONString);
                const sourceSs = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
                const sourceSheet = sourceSs.getSheetByName(query.from[0]); // Assuming one sheet for now
                const sourceHeaders = sourceSheet.getRange(1, 1, 1, sourceSheet.getLastColumn()).getValues()[0];

                const outputSheet = outputSs.getSheets()[0];
                const headersToWrite = (query.select && query.select.length > 0 && query.select[0] !== '*') ? query.select : sourceHeaders;
                outputSheet.appendRow(headersToWrite);

                state = {
                    queryJSON: queryJSONString,
                    lastRowProcessed: 0,
                    aggregationMap: {},
                    outputSheetId: outputSheetId
                };

                const urlCol = headers.indexOf("OutputSheetURL");
                queueSheet.getRange(queryRowIndex, urlCol + 1).setValue(outputUrl);
                SpreadsheetApp.flush();
            }

            const query = JSON.parse(state.queryJSON);
            const CHUNK_SIZE = 500;
            const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
            const sourceSheet = ss.getSheetByName(query.from[0]);

            if (!sourceSheet) {
              // Handle error: Update queue and terminate for this query
              return;
            }

            const maxRows = sourceSheet.getLastRow();
            const startRow = state.lastRowProcessed + 1;
            if (startRow > maxRows) { // Check if we are already done
              // Query is finished, move to completion logic
            } else {
                const numRowsToProcess = Math.min(CHUNK_SIZE, maxRows - state.lastRowProcessed);

                if (numRowsToProcess > 0) {
                    const sheetData = sourceSheet.getRange(startRow + 1, 1, numRowsToProcess, sourceSheet.getLastColumn()).getValues();
                    const headers = sourceSheet.getRange(1, 1, 1, sourceSheet.getLastColumn()).getValues()[0];
                    const filteredData = sheetData.filter(row => evaluateWhereClause(row, headers, query.where));

                    if (query.groupBy && query.groupBy.length > 0) {
                        const cache = CacheService.getScriptCache();
                        let aggregationMap = JSON.parse(cache.get(queryId) || '{}');

                        const groupByCols = query.groupBy;
                        const selectCols = query.select;
                        const aggRegex = /(\w+)\((.*?)\)/;

                        filteredData.forEach(row => {
                            const groupKey = groupByCols.map(col => row[headers.indexOf(col)]).join('||');

                            if (!aggregationMap[groupKey]) {
                                aggregationMap[groupKey] = {};
                                groupByCols.forEach(col => {
                                    aggregationMap[groupKey][col] = row[headers.indexOf(col)];
                                });
                            }

                            selectCols.forEach(selectCol => {
                                const match = selectCol.match(aggRegex);
                                if (match) {
                                    const func = match[1].toUpperCase();
                                    const col = match[2];
                                    const colIndex = headers.indexOf(col);
                                    const val = parseFloat(row[colIndex]) || 0;

                                    if (!aggregationMap[groupKey][selectCol]) {
                                        aggregationMap[groupKey][selectCol] = { sum: 0, count: 0 };
                                    }

                                    aggregationMap[groupKey][selectCol].sum += val;
                                    aggregationMap[groupKey][selectCol].count++;
                                }
                            });
                        });

                        cache.put(queryId, JSON.stringify(aggregationMap), 21600); // 6 hours expiration

                    } else {
                        if (filteredData.length > 0) {
                            const outputSs = SpreadsheetApp.openById(state.outputSheetId);
                            const outputSheet = outputSs.getSheets()[0];
                            const headersToWrite = (query.select && query.select.length > 0 && query.select[0] !== '*') ? query.select : headers;

                            const dataToWrite = filteredData.map(row => {
                                return headersToWrite.map(header => {
                                    const colIndex = headers.indexOf(header);
                                    return colIndex !== -1 ? row[colIndex] : `_ERR_COL_NOT_FOUND: ${header}`;
                                });
                            });

                            if (dataToWrite.length > 0) {
                                outputSheet.getRange(outputSheet.getLastRow() + 1, 1, dataToWrite.length, dataToWrite[0].length).setValues(dataToWrite);
                            }
                        }
                    }

                    state.lastRowProcessed += numRowsToProcess;
                    properties.setProperty(`state_${queryId}`, JSON.stringify(state));

                    if(state.lastRowProcessed >= maxRows -1) {
                        // break the while loop to go to completion logic
                        break;
                    } else {
                       continue; // Continue processing chunks in the while loop
                    }
                }
            }

            // --- COMPLETION LOGIC ---
            const outputSs = SpreadsheetApp.openById(state.outputSheetId);
            const outputUrl = outputSs.getUrl();

            if (query.groupBy && query.groupBy.length > 0) {
                const cache = CacheService.getScriptCache();
                const aggregationMap = JSON.parse(cache.get(queryId) || '{}');
                const outputSheet = outputSs.getSheets()[0];
                const headers = query.select;

                const results = Object.values(aggregationMap).map(group => {
                    return headers.map(header => {
                        if (group[header] && typeof group[header] === 'object') {
                            const aggData = group[header];
                            if (header.toUpperCase().startsWith('AVG(')) {
                                return aggData.count > 0 ? aggData.sum / aggData.count : 0;
                            } else if (header.toUpperCase().startsWith('SUM(')) {
                                return aggData.sum;
                            } else if (header.toUpperCase().startsWith('COUNT(')) {
                                return aggData.count;
                            }
                        }
                        return group[header];
                    });
                });

                outputSheet.clearContents().appendRow(headers);
                if (results.length > 0) {
                    outputSheet.getRange(2, 1, results.length, headers.length).setValues(results);
                }
                cache.remove(queryId);
            }

            const queueSs = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
            const queueSheet = queueSs.getSheetByName("QueryQueue");
            const data = queueSheet.getDataRange().getValues();
            const qHeaders = data.shift();
            const qIdCol = qHeaders.indexOf("QueryID");
            const statusColIdx = qHeaders.indexOf("Status");
            const endTimeCol = qHeaders.indexOf("EndTime");

            for (let i = 0; i < data.length; i++) {
                if (data[i][qIdCol] === queryId) {
                    queueSheet.getRange(i + 2, statusColIdx + 1).setValue("Complete");
                    queueSheet.getRange(i + 2, endTimeCol + 1).setValue(new Date());
                    break;
                }
            }

            if (query.action && query.action.type === 'email' && query.action.recipient) {
                MailApp.sendEmail({
                    to: query.action.recipient, cc: query.action.cc || '',
                    subject: `Query Engine Result: ${queryId}`,
                    body: `Your query has completed. You can view the results at:\n\n${outputUrl}`
                });
            }

            properties.deleteProperty('currentQueryID');
            properties.deleteProperty(`state_${queryId}`);
            queryId = null; // Reset for the next loop
        }
    } catch (e) {
        Logger.log(`ERROR in runQueryEngineBatch for query ${queryId}: ${e.toString()}`);
        // TODO: Update queue with error message
    } finally {
        lock.releaseLock();
        if (queryId) { // If loop timed out but a query was running
            ScriptApp.newTrigger('runQueryEngineBatch').timeBased().after(60 * 1000).create();
        }
    }
}

function evaluateWhereClause(row, headers, where) {
  if (!where || !where.groups || where.groups.length === 0) {
    return true; // If no WHERE clause, all rows pass
  }

  const rootLogic = where.logic; // AND or OR

  for (let i = 0; i < where.groups.length; i++) {
    const group = where.groups[i];
    const groupResult = evaluateGroup(row, headers, group);

    if (rootLogic === 'AND' && !groupResult) {
      return false; // For AND, if any group is false, the whole thing is false
    }
    if (rootLogic === 'OR' && groupResult) {
      return true; // For OR, if any group is true, the whole thing is true
    }
  }

  return rootLogic === 'AND'; // If AND and we haven't returned false, it's true. If OR and we haven't returned true, it's false.
}

function evaluateGroup(row, headers, group) {
  if (!group.rules || group.rules.length === 0) {
    return true;
  }

  const groupLogic = group.logic; // AND or OR

  for (let i = 0; i < group.rules.length; i++) {
    const rule = group.rules[i];
    const ruleResult = applyRule(row, headers, rule);

    if (groupLogic === 'AND' && !ruleResult) {
      return false;
    }
    if (groupLogic === 'OR' && ruleResult) {
      return true;
    }
  }

  return groupLogic === 'AND';
}

function applyRule(row, headers, rule) {
  const colIndex = headers.indexOf(rule.column);
  if (colIndex === -1) {
    return false; // Column not found
  }

  const cellValue = row[colIndex];
  const ruleValue = rule.value;

  switch (rule.operator) {
    case 'is': return cellValue == ruleValue;
    case 'is_not': return cellValue != ruleValue;
    case 'contains': return String(cellValue).includes(ruleValue);
    case 'does_not_contain': return !String(cellValue).includes(ruleValue);
    case 'starts_with': return String(cellValue).startsWith(ruleValue);
    case 'does_not_start_with': return !String(cellValue).startsWith(ruleValue);
    case 'ends_with': return String(cellValue).endsWith(ruleValue);
    case 'does_not_end_with': return !String(cellValue).endsWith(ruleValue);
    case 'is_blank': return cellValue === '' || cellValue === null || cellValue === undefined;
    case 'is_not_blank': return cellValue !== '' && cellValue !== null && cellValue !== undefined;
    // Basic numeric/date comparison. Assumes clean data.
    case 'is_greater_than': return cellValue > ruleValue;
    case 'is_less_than': return cellValue < ruleValue;
    case 'is_greater_than_or_equal_to': return cellValue >= ruleValue;
    case 'is_less_than_or_equal_to': return cellValue <= ruleValue;
    // More complex operators
    case 'is_one_of': return ruleValue.split(',').map(v => v.trim()).includes(String(cellValue));
    case 'is_not_one_of': return !ruleValue.split(',').map(v => v.trim()).includes(String(cellValue));
    case 'is_between':
      const parts = ruleValue.split(',').map(v => v.trim());
      return cellValue >= parts[0] && cellValue <= parts[1];
    case 'is_not_between':
        const notParts = ruleValue.split(',').map(v => v.trim());
        return cellValue < notParts[0] || cellValue > notParts[1];
    case 'matches_regex':
      try {
        return new RegExp(ruleValue).test(cellValue);
      } catch (e) {
        return false;
      }
    case 'does_not_match_regex':
      try {
        return !new RegExp(ruleValue).test(cellValue);
      } catch (e) {
        return false;
      }
    default: return false;
  }
}

function saveQueryToLibrary(name, description, queryJson) {
  try {
    if (!name || !queryJson) {
      throw new Error("Query name and JSON are required to save to the library.");
    }
    const userEmail = Session.getActiveUser().getEmail();
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const librarySheet = ss.getSheetByName("QueryLibrary");
    if (!librarySheet) {
      throw new Error("QueryLibrary sheet not found.");
    }
    librarySheet.appendRow([name, description || "", queryJson, userEmail]);
    return `Query "${name}" was successfully saved to your library.`;
  } catch (e) {
    Logger.log(`Error in saveQueryToLibrary: ${e.toString()}`);
    throw new Error(`Could not save query: ${e.message}`);
  }
}

function getQueriesFromLibrary() {
  try {
    const userEmail = Session.getActiveUser().getEmail();
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const librarySheet = ss.getSheetByName("QueryLibrary");
    if (!librarySheet || librarySheet.getLastRow() < 2) {
      return [];
    }
    const data = librarySheet.getRange(2, 1, librarySheet.getLastRow() - 1, 4).getValues();
    return data
      .filter(row => row[3] === userEmail) // Filter by user's email in the 4th column
      .map(row => ({
        name: row[0],
        description: row[1],
        queryJson: row[2]
      }));
  } catch (e) {
    Logger.log(`Error in getQueriesFromLibrary: ${e.toString()}`);
    return []; // Return empty on error to not break the UI
  }
}

function getSheetHeaders(sheetName) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      throw new Error(`Sheet "${sheetName}" not found.`);
    }
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    return headers.filter(header => header); // Filter out empty header cells
  } catch (e) {
    Logger.log(`Error in getSheetHeaders: ${e.toString()}`);
    throw new Error(`Could not retrieve headers for sheet "${sheetName}".`);
  }
}

function getAllSheetNames() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheets = ss.getSheets();
    return sheets.map(sheet => sheet.getName());
  } catch (e) {
    Logger.log(`Error in getAllSheetNames: ${e.toString()}`);
    throw new Error("Could not retrieve sheet names.");
  }
}
