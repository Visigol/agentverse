/**
 * @fileoverview Main server-side script for the BoltVerse Attendance & Production App.
 * Refactored for a standalone web app architecture to read from multiple spreadsheets.
 * @version 8.1 (Consolidated Config - Complete)
 */

// =================================================================================
// --- CENTRALIZED CONFIGURATION (SIMPLIFIED) ---
// =================================================================================
// INSTRUCTIONS: Replace the placeholder IDs with your actual Google Spreadsheet IDs.
const CONFIG = {
  // Spreadsheet containing agent/manager lists, logs, and general settings
  ATTENDANCE: {
    ID: '1-3UfwCsL9dc3brmTCxYpbqfuCeDGEvSIz-Cfm_iqoYI',
    SHEETS: {
      AGENT_LOG: "AgentLog",
      CASE_LOG: "CaseLog",
      AGENTS: "Agents",
      MANAGERS: "Managers",
      REQUESTS: "Requests",
      IMPORTANT_LINKS: "Important Links",
      VERSION_CONFIG: "UpdateConfig",
      IMPORTANT_LINKS_MANAGER: "Important Links Manager"
    }
  },
  // Spreadsheet containing the main production/case data (THE TARGET)
  PRODUCTION: {
    ID: '1AaJmBfDpZnk0J1A4WbInEPuspUyae5jXm42SyQIaJn8',
    SHEETS: {
      AVAILABLE_CASES: "Main Tasks",
      // --- ADDITIONS START ---
      // Add the names of the log sheets as they will appear in your TARGET spreadsheet.
      ESCALATION_LOGS: "Escalation Logs",
      PAUSING_LOGS: "Pausing Logs",
      COOPERATION_LOGS: "Cooperation Logs"
      // --- ADDITIONS END ---
    }
  },
  // Source spreadsheet for the daily case sync
  SOURCE_DATA: {
    ID: '1AaJmBfDpZnk0J1A4WbInEPuspUyae5jXm42SyQIaJn8', // This was the hardcoded ID
    SHEETS: {
      MAIN_TASKS: "Main Tasks",
      // --- ADDITIONS START ---
      // Add the names of the log sheets as they appear in your SOURCE spreadsheet.
      ESCALATION_LOGS: "Escalation Logs",
      PAUSING_LOGS: "Pausing Logs",
      COOPERATION_LOGS: "Cooperation Logs"
      // --- ADDITIONS END ---
    },
    // --- ADDITIONS START ---
    // This new block is essential. It tells the script which column contains the
    // unique ID for each record in each source sheet.
    PRIMARY_KEYS: {
      "Main Tasks": "Main Task ID",
      "Escalation Logs": "Log ID",
      "Cooperation Logs": "Log ID",
      "Pausing Logs": "ID"
    }
    // --- ADDITIONS END ---
  }
};

// IMPORTANT: Manually update this version number in the script before deploying a new version.
const SCRIPT_APP_VERSION = "8.1";

// Fallback if Managers sheet is not found or has issues
const MANAGER_EMAILS_FALLBACK = ["manager1@example.com", "your.manager.email@example.com"];

// =================================================================================
// --- WEB APP ROUTER ---
// =================================================================================

function doGet(e) {
  let userEmail = null;
  try {
    userEmail = Session.getActiveUser().getEmail();
  }
  catch (err) {
    Logger.log("Could not get active user email in doGet: " + err);
  }

  // Check if the user is a manager
  if (userEmail && isUserManager_(userEmail)) {
    // If the URL asks for the 'production' page, show it.
    if (e.parameter.page === 'production') {
      return HtmlService.createHtmlOutputFromFile('production')
        .setTitle('Production Dashboard')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    }
    // --- ADD THIS BLOCK ---
    else if (e.parameter.page === 'cases') {
      return HtmlService.createHtmlOutputFromFile('cases')
        .setTitle('Case Management')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    }
    // --- END ADDITION ---
    else {
      // Otherwise, show the default manager homepage.
      return HtmlService.createTemplateFromFile('manager').evaluate()
        .setTitle('Manager Dashboard')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
    }
  } else {
    // If not a manager, show the agent index page.
    return HtmlService.createHtmlOutputFromFile('index')
      .setTitle('Agent Status Tracker')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
}

// =================================================================================
// --- HELPER & UTILITY FUNCTIONS ---
// =================================================================================

function isUserManager_(email) {
  if (!email) return false;
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const managerSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.MANAGERS);
    if (!managerSheet) {
      Logger.log(`Sheet "${CONFIG.ATTENDANCE.SHEETS.MANAGERS}" not found. Using fallback list.`);
      return MANAGER_EMAILS_FALLBACK.includes(email.trim().toLowerCase());
    }
    const managerEmails = managerSheet.getRange("A2:A" + managerSheet.getLastRow()).getValues()
      .flat().map(e => e.toString().trim().toLowerCase()).filter(Boolean);
    return managerEmails.includes(email.trim().toLowerCase());
  } catch (e) {
    Logger.log("Error checking manager status: " + e + ". Falling back to hardcoded list.");
    return MANAGER_EMAILS_FALLBACK.includes(email.trim().toLowerCase());
  }
}

/**
 * Logs a detailed correction request from the agent's attendance log, including the proposed new timestamp.
 */
function logCorrectionRequest(originalLogData, reason, newTimestampStr) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.REQUESTS);
    if (!sheet) {
      throw new Error(`Sheet '${CONFIG.ATTENDANCE.SHEETS.REQUESTS}' not found.`);
    }

    const userEmail = Session.getActiveUser().getEmail();
    const approvalStatus = "Waiting to be Approved";
    const newTimestamp = new Date(newTimestampStr); // Convert string to Date object for storage

    // Appends a new row in the new, detailed format
    sheet.appendRow([
      userEmail,                // A: Agent Email
      originalLogData.timestamp,// B: Original Timestamp
      originalLogData.action,   // C: Original Action
      originalLogData.sessionId,// D: Original Session ID
      reason,                   // E: Reason for Correction
      approvalStatus,           // F: Status
      "",                       // G: Reviewed By
      newTimestamp              // H: Corrected Timestamp
    ]);

    return "Correction request submitted successfully!";

  } catch (e) {
    console.error("logCorrectionRequest Error: " + e.toString());
    throw new Error("Could not submit request. " + e.message);
  }
}

// =================================================================================
// --- DATA & HELPER FUNCTIONS ---
// =================================================================================

/**
 * Fetches important links for the main agent dashboard.
 * @returns {Array<Object>} An array of link objects.
 */
function getImportantLinks() {
  Logger.log("--- Starting getImportantLinks ---");
  try {
    const spreadsheetId = CONFIG.ATTENDANCE.ID;
    const sheetName = CONFIG.ATTENDANCE.SHEETS.IMPORTANT_LINKS;
    Logger.log(`Attempting to open Spreadsheet ID: ${spreadsheetId}`);

    const ss = SpreadsheetApp.openById(spreadsheetId);
    Logger.log("Spreadsheet opened successfully.");

    Logger.log(`Attempting to get sheet named: "${sheetName}"`);
    const sheet = ss.getSheetByName(sheetName);

    if (!sheet) {
      Logger.log(`ERROR: Sheet "${sheetName}" was not found.`);
      return [];
    }
    Logger.log(`Sheet "${sheetName}" found successfully.`);

    const lastRow = sheet.getLastRow();
    if (lastRow < 2) {
      Logger.log("Sheet has no data rows (only header or is empty).");
      return [];
    }

    const dataRange = sheet.getRange(2, 1, lastRow - 1, 4);
    const rawData = dataRange.getValues();
    Logger.log(`Found ${rawData.length} rows of data.`);
    // Logger.log(`Raw data from sheet: ${JSON.stringify(rawData)}`); // Optional: Uncomment to see the actual data

    const links = rawData.map(row => ({
      category: row[0],
      name: row[1],
      url: row[2],
      description: row[3]
    })).filter(link => link.category && link.name && link.url);

    Logger.log(`Processed and filtered ${links.length} valid links.`);
    Logger.log("--- Finished getImportantLinks ---");
    return links;

  } catch (e) {
    Logger.log(`CRITICAL ERROR in getImportantLinks: ${e.toString()}`);
    throw new Error("Could not fetch Important Links. " + e.message);
  }
}


/**
 * Gets important links specifically for managers.
 */
function getManagerImportantLinks() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.IMPORTANT_LINKS_MANAGER);
    if (!sheet) {
      console.warn(`Sheet '${CONFIG.ATTENDANCE.SHEETS.IMPORTANT_LINKS_MANAGER}' not found, returning empty array.`);
      return [];
    }
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4).getValues();
    return data.map(row => ({
      category: row[0],
      name: row[1],
      url: row[2],
      description: row[3]
    })).filter(link => link.category && link.name && link.url);
  } catch (e) {
    console.error("getManagerImportantLinks Error: " + e.toString());
    throw new Error("Could not fetch Manager Important Links. " + e.message);
  }
}


function getVersionDetails() {
  Logger.log("--- Starting getVersionDetails ---");
  try {
    const spreadsheetId = CONFIG.ATTENDANCE.ID;
    const sheetName = CONFIG.ATTENDANCE.SHEETS.VERSION_CONFIG;
    Logger.log(`Attempting to open Spreadsheet ID: ${spreadsheetId}`);

    const ss = SpreadsheetApp.openById(spreadsheetId);
    Logger.log("Spreadsheet opened successfully.");

    Logger.log(`Attempting to get sheet named: "${sheetName}"`);
    const versionSheet = ss.getSheetByName(sheetName);

    if (!versionSheet) {
      Logger.log(`ERROR: Config sheet "${sheetName}" not found.`);
      return { runningVersion: SCRIPT_APP_VERSION, error: `Config sheet "${sheetName}" not found.` };
    }
    Logger.log(`Sheet "${sheetName}" found successfully.`);

    const data = versionSheet.getRange("A2:B" + Math.max(2, versionSheet.getLastRow())).getValues();
    Logger.log(`Found ${data.length} rows of config data.`);
    // Logger.log(`Raw config data: ${JSON.stringify(data)}`); // Optional: Uncomment to see the data

    const config = Object.fromEntries(data.filter(row => row[0]).map(row => [row[0].toString().trim(), row[1] ? row[1].toString().trim() : ""]));
    Logger.log(`Processed config object: ${JSON.stringify(config)}`);

    Logger.log("--- Finished getVersionDetails ---");
    return {
      runningVersion: SCRIPT_APP_VERSION,
      latestAdvertisedVersion: config['LatestVersion'] || SCRIPT_APP_VERSION,
      updateURL: config['LatestVersionURL'] || "",
      updateFeatures: config['LatestFeatures'] || "N/A",
      error: null
    };
  } catch (e) {
    Logger.log(`CRITICAL ERROR in getVersionDetails: ${e.message}`);
    return { runningVersion: SCRIPT_APP_VERSION, error: `Error fetching version details: ${e.message}` };
  }
}


// --- VERSION INFO FUNCTIONS ---
function fetchVersionInformation() {
    google.script.run
        .withSuccessHandler(handleVersionDetailsResponse)
        .withFailureHandler(handleVersionDetailsError)
        .getVersionDetails();
}

function handleVersionDetailsResponse(versionInfo) {
    const versionDisplayEl = document.getElementById('scriptVersionDisplay');
    const statusMsgEl = document.getElementById('versionStatusMessage');
    const updateNotificationEl = document.getElementById('updateNotificationArea');
    const updateButtonEl = document.getElementById('updateButton');
    const featuresDisplayEl = document.getElementById('updateFeaturesDisplay');
    const versionErrorEl = document.getElementById('versionError');
    if (!versionDisplayEl || !statusMsgEl || !updateNotificationEl) return;

    versionErrorEl.style.display = 'none';
    if (versionInfo && versionInfo.error) {
        versionDisplayEl.textContent = "Error";
        updateNotificationEl.style.display = 'none';
        versionErrorEl.textContent = versionInfo.error;
        versionErrorEl.style.display = 'block';
        return;
    }
    if (versionInfo && versionInfo.runningVersion) {
        versionDisplayEl.textContent = versionInfo.runningVersion;
        const running = parseFloat(versionInfo.runningVersion);
        const latest = parseFloat(versionInfo.latestAdvertisedVersion);
        if (!isNaN(running) && !isNaN(latest) && versionInfo.latestAdvertisedVersion && versionInfo.updateURL && running < latest) {
            updateNotificationEl.style.display = 'block';
            featuresDisplayEl.textContent = versionInfo.updateFeatures || "No features listed.";
            updateButtonEl.onclick = () => promptForUpdate(versionInfo.updateURL, versionInfo.updateFeatures);
        } else {
            statusMsgEl.textContent = "Up to date.";
            updateNotificationEl.style.display = 'none';
        }
    } else {
        versionDisplayEl.textContent = "N/A";
        versionErrorEl.textContent = "Could not retrieve version info.";
        versionErrorEl.style.display = 'block';
    }
}

function handleVersionDetailsError(error) {
    console.error("Error fetching version details:", error);
    document.getElementById('scriptVersionDisplay').textContent = "Error";
    document.getElementById('versionError').textContent = "Failed to check for updates.";
    document.getElementById('versionError').style.display = 'block';
}

function promptForUpdate(newUrl, features) {
    if (!newUrl) { alert("Update URL is not configured."); return; }
    window.open(newUrl, '_blank');
    const bookmarkShortcut = navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 'Cmd+D' : 'Ctrl+D';
    let alertMessage = "A new version has opened in a new tab.\n\n";
    if (features) { alertMessage += "New features:\n- " + features.replace(/,\s*/g, "\n- ") + "\n\n"; }
    alertMessage += "Please bookmark the new page (try " + bookmarkShortcut + ") and remove your old bookmark.";
    alert(alertMessage);
}
/**
 * Fetches a list of all agents (email and name) to populate dropdowns.
 */
function getAllAgents() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENTS);
    if (!sheet || sheet.getLastRow() < 2) {
      return []; // Return empty if no sheet or no agents
    }
    // Reads Column A (Email) and Column B (Name)
    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 2).getValues();

    return data
      .map(row => ({ email: row[0], name: row[1] }))
      .filter(agent => agent.email); // Filter out any empty rows
  } catch (e) {
    Logger.log("Error in getAllAgents: " + e.toString());
    return []; // Return empty on error
  }
}

/**
 * Fetches the attendance log for a specific agent selected by the manager.
 */
function getLogForSelectedAgent(agentEmail, dateRange) {
  try {
    if (!agentEmail) {
      throw new Error("No agent email provided.");
    }
    const startDate = new Date(dateRange.startDate);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(dateRange.endDate);
    endDate.setHours(23, 59, 59, 999);

    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    if (!sheet) {
      throw new Error("AgentLog sheet not found.");
    }

    const allData = sheet.getDataRange().getValues();
    allData.shift(); // Remove headers

    const agentLogs = allData.filter(row => {
      const rowEmail = (row[1] || "").toString().trim().toLowerCase();
      if (rowEmail !== agentEmail.toLowerCase()) {
        return false;
      }
      const timestamp = row[0] instanceof Date ? row[0] : new Date(row[0]);
      return timestamp >= startDate && timestamp <= endDate;
    });

    return agentLogs.map(row => {
      const timestamp = row[0] instanceof Date ? row[0] : new Date(row[0]);
      return {
        timestamp: timestamp.toISOString(),
        action: row[3],
        sessionId: row[4]
      };
    }).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

  } catch (e) {
    Logger.log("Error in getLogForSelectedAgent: " + e.toString());
    throw new Error("Failed to retrieve attendance log. " + e.message);
  }
}




/**
 * Fetches the current agent's pending correction requests for their UI.
 */
function getPendingRequests() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.REQUESTS);
    if (!sheet) return [];

    const userEmail = Session.getActiveUser().getEmail();
    const allData = sheet.getDataRange().getValues();
    allData.shift(); // Remove header row

    const userRequests = allData.filter(row => {
      const requestAgentEmail = row[0]; // Agent Email in Column A
      const status = row[5]; // Status in Column F
      return requestAgentEmail === userEmail && status === "Waiting to be Approved";
    });

    return userRequests.map(row => {
      const correctedTimestamp = row[7] instanceof Date ? Utilities.formatDate(row[7], Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss") : "N/A";
      const originalTimestamp = row[1] instanceof Date ? Utilities.formatDate(row[1], Session.getScriptTimeZone(), "yyyy-MM-dd HH:mm:ss") : row[1];

      return {
        sessionId: row[3],          // Original Session ID from Column D
        originalAction: row[2],     // Original Action from Column C
        originalTimestamp: originalTimestamp, // Original Timestamp from Column B
        correctedTimestamp: correctedTimestamp // Corrected Timestamp from Column H
      };
    });

  } catch (e) {
    console.error("getPendingRequests Error: " + e.toString());
    throw new Error("Could not fetch pending requests. " + e.message);
  }
}

// =================================================================================
// --- AGENT-FACING FUNCTIONS ---
// =================================================================================

function getInitialAgentState() {
  Logger.log("--- Starting getInitialAgentState ---");
  let agentEmail = "Unknown";
  try {
    const activeUser = Session.getActiveUser();
    agentEmail = activeUser ? activeUser.getEmail() : "Unknown";
    Logger.log(`Step 1: User identified as ${agentEmail}`);

    if (!agentEmail || agentEmail === "Unknown") {
      Logger.log("ERROR: No active user or email found.");
      return { ..._getFallbackStateForAgent(agentEmail, ""), error: "Could not retrieve agent email." };
    }

    const agentName = getAgentName_(agentEmail);
    Logger.log(`Step 2: Agent name found: ${agentName}`);

    const state = _determineCurrentAgentState(agentEmail, agentName);
    Logger.log(`Step 3: Final state determined: ${JSON.stringify(state)}`);
    Logger.log("--- Finished getInitialAgentState successfully ---");
    return state;

  } catch (e) {
    Logger.log(`CRITICAL ERROR in getInitialAgentState for ${agentEmail}: ${e.toString()} at stack: ${e.stack}`);
    return { ..._getFallbackStateForAgent(agentEmail, getAgentName_(agentEmail)), error: `ERROR: Could not fetch initial state: ${e.message}` };
  }
}

function logAgentAction(actionType) {
  let agentEmail = ""; let agentName = "";
  try {
    agentEmail = Session.getActiveUser().getEmail();
    agentName = getAgentName_(agentEmail);
    Logger.log(`logAgentAction called by ${agentEmail} for action: ${actionType}`);

    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const agentLogSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    if (!agentLogSheet) return { ..._getFallbackStateForAgent(agentEmail, agentName), error: `Sheet "${CONFIG.ATTENDANCE.SHEETS.AGENT_LOG}" not found.`, messageType: "error" };

    const timestamp = new Date();
    let sessionIdToLog = null;
    let currentStateBeforeAction = _determineCurrentAgentState(agentEmail, agentName);
    Logger.log(`State before action ${actionType} for ${agentEmail}: ${JSON.stringify(currentStateBeforeAction)}`);

    if (actionType === "Start Work") {
      if (currentStateBeforeAction.isWorking) return { ...currentStateBeforeAction, error: "Already in an active work session. 'End Work' first.", messageType: "error" };
      sessionIdToLog = agentEmail + "_" + timestamp.getTime();
    } else {
      if (!currentStateBeforeAction.isWorking) return { ...currentStateBeforeAction, error: "Must 'Start Work' first.", messageType: "error" };
      sessionIdToLog = currentStateBeforeAction.currentSessionId;
      if (!sessionIdToLog) {
        Logger.log(`CRITICAL: isWorking true but no currentSessionId for ${agentEmail} before ${actionType}`);
        return { ...currentStateBeforeAction, error: "State inconsistency - no active session ID. 'End Work' & 'Start Work' again.", messageType: "error" };
      }
      if (actionType === "Start Break") {
        if (currentStateBeforeAction.isOnBreak) return { ...currentStateBeforeAction, error: "Already on a break.", messageType: "error" };
        if (currentStateBeforeAction.isInMeeting) return { ...currentStateBeforeAction, error: "Cannot start break while in a meeting.", messageType: "error" };
      } else if (actionType === "End Break") {
        if (!currentStateBeforeAction.isOnBreak) return { ...currentStateBeforeAction, error: "Not currently on a break.", messageType: "error" };
      } else if (actionType === "Start Meeting") {
        if (currentStateBeforeAction.isInMeeting) return { ...currentStateBeforeAction, error: "Already in a meeting.", messageType: "error" };
        if (currentStateBeforeAction.isOnBreak) return { ...currentStateBeforeAction, error: "Cannot start meeting while on break.", messageType: "error" };
      } else if (actionType === "End Meeting") {
        if (!currentStateBeforeAction.isInMeeting) return { ...currentStateBeforeAction, error: "Not currently in a meeting.", messageType: "error" };
      }
    }

    agentLogSheet.appendRow([timestamp, agentEmail, agentName, actionType, sessionIdToLog]);
    Logger.log(`Logged Agent Action to Sheet: ${agentEmail}, ${actionType}, Session: ${sessionIdToLog}`);

    const newState = _determineCurrentAgentState(agentEmail, agentName);
    Logger.log(`New state after action ${actionType} for ${agentEmail}: ${JSON.stringify(newState)}`);
    return { ...newState, message: `Action "${actionType}" logged.`, messageType: "success" };
  } catch (e) {
    Logger.log(`Error in logAgentAction for ${agentEmail}, action ${actionType}: ${e.toString()} Stack: ${e.stack}`);
    return { ..._getFallbackStateForAgent(agentEmail, agentName), error: `Could not log agent action: ${e.message}`, messageType: "error" };
  }
}

function logCaseAction(actionType, caseId, caseDetails) {
  let agentEmail = ""; let agentName = "";
  try {
    agentEmail = Session.getActiveUser().getEmail();
    agentName = getAgentName_(agentEmail);
    Logger.log(`logCaseAction called by ${agentEmail} for action: ${actionType}, Case ID: ${caseId}`);
    let currentState = _determineCurrentAgentState(agentEmail, agentName);

    if (!currentState.isWorking || currentState.isOnBreak || currentState.isInMeeting) {
      return { ...currentState, error: "Must be working (not on break/meeting) to manage cases.", messageType: "error" };
    }
    if (!currentState.currentSessionId) return { ...currentState, error: "No active work session for case logging.", messageType: "error" };

    const ssAttendance = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const caseLogSheet = ssAttendance.getSheetByName(CONFIG.ATTENDANCE.SHEETS.CASE_LOG);
    if (!caseLogSheet) return { ...currentState, error: `Sheet "${CONFIG.ATTENDANCE.SHEETS.CASE_LOG}" not found.`, messageType: "error" };

    const timestamp = new Date();
    const trimmedCaseId = caseId ? caseId.toString().trim() : "";

    if (!trimmedCaseId && (actionType === "Start Case" || actionType === "Start Returned Case" || actionType === "Finish Case" || actionType === "Escalate Case")) {
      return { ...currentState, error: "Case ID cannot be empty for this action.", messageType: "error" };
    }

    const existingOpenCase = currentState.agentOpenCases.find(c => c.caseId === trimmedCaseId);

    if (actionType === "Start Case") {
      // Allow starting a new case even if others are open by this agent.
    } else if (actionType === "Start Returned Case") {
      if (!existingOpenCase) return { ...currentState, error: `Case ${trimmedCaseId} not found in your handling list to resume.`, messageType: "error" };
      if (!existingOpenCase.isEscalated) return { ...currentState, error: `Case ${trimmedCaseId} is not marked as escalated.`, messageType: "error" };
    } else if (actionType === "Finish Case" || actionType === "Escalate Case") {
      if (!existingOpenCase) return { ...currentState, error: `Case ${trimmedCaseId} not found in your handling list.`, messageType: "error" };
      if (actionType === "Escalate Case" && existingOpenCase.isEscalated) {
        return { ...currentState, error: `Case ${trimmedCaseId} is already escalated.`, messageType: "error" };
      }
    } else {
      return { ...currentState, error: `Unknown case action: ${actionType}`, messageType: "error" };
    }

    caseLogSheet.appendRow([timestamp, agentEmail, agentName, trimmedCaseId, actionType, caseDetails || "", currentState.currentSessionId]);
    Logger.log(`Logged Case Action to Sheet: ${agentEmail}, ${actionType}, Case: ${trimmedCaseId}, Session: ${currentState.currentSessionId}`);

    if (actionType === "Finish Case" || actionType === "Escalate Case" || actionType === "Start Returned Case") {
      const ssProduction = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
      const availableCasesSheet = ssProduction.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
      if (availableCasesSheet) {
        const data = availableCasesSheet.getDataRange().getValues();
        const header = data.length > 0 ? data[0].map(h => h.toString().trim().toLowerCase()) : [];
        const caseIdColIndex = header.indexOf("main task id");
        const statusColIndex = header.indexOf("status");
        if (caseIdColIndex !== -1 && statusColIndex !== -1) {
          for (let i = 1; i < data.length; i++) {
            if (data[i][caseIdColIndex] && data[i][caseIdColIndex].toString().trim() === trimmedCaseId) {
              let newStatus = "";
              if (actionType === "Finish Case") newStatus = "Finished";
              else if (actionType === "Escalate Case") newStatus = "Escalated";
              else if (actionType === "Start Returned Case") newStatus = "In Progress";
              if (newStatus) {
                availableCasesSheet.getRange(i + 1, statusColIndex + 1).setValue(newStatus);
                Logger.log(`Updated status of Case ID ${trimmedCaseId} to "${newStatus}" in ${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}.`);
              }
              break;
            }
          }
        } else { Logger.log(`Could not find 'Main Task ID' or 'Status' column in ${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}.`); }
      }
    }

    const newState = _determineCurrentAgentState(agentEmail, agentName);
    return { ...newState, message: `Case action "${actionType}" for [${trimmedCaseId}] logged.`, messageType: "success" };
  } catch (e) {
    Logger.log(`Error in logCaseAction for ${agentEmail}, action ${actionType}, case ${caseId}: ${e.toString()} Stack: ${e.stack}`);
    return { ..._getFallbackStateForAgent(agentEmail, agentName), error: `Could not log case action: ${e.message}`, messageType: "error" };
  }
}

function _getFallbackStateForAgent(agentEmail, agentName) {
  return {
    agentEmail: agentEmail || "Unknown", agentName: agentName || (agentEmail ? agentEmail.split('@')[0] : ""),
    isWorking: false, isOnBreak: false, isInMeeting: false,
    currentSessionId: null,
    workSessionActualStartTimeISO: null,
    totalCompletedBreakDurationInSessionSeconds: 0,
    totalCompletedMeetingDurationInSessionSeconds: 0,
    currentBreakStartTimeISO: null,
    currentMeetingStartTimeISO: null,
    agentOpenCases: [],
  };
}

function _determineCurrentAgentState(agentEmail, agentName) {
  Logger.log("--- Starting _determineCurrentAgentState ---");
  const state = _getFallbackStateForAgent(agentEmail, agentName);

  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const agentLogSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    if (!agentLogSheet) {
      Logger.log(`ERROR: Sheet "${CONFIG.ATTENDANCE.SHEETS.AGENT_LOG}" not found. Returning fallback state.`);
      return state;
    }
    Logger.log("AgentLog sheet found successfully.");

    // --- Part 1: Determine current work/break/meeting status ---
    const agentLogAllData = agentLogSheet.getDataRange().getValues();
    Logger.log(`Read ${agentLogAllData.length} total rows from AgentLog.`);

    const agentEntries = agentLogAllData
      .filter(row => row[1] && String(row[1]).trim().toLowerCase() === agentEmail.toLowerCase())
      .map(row => ({
        timestamp: new Date(row[0]),
        action: row[3] ? String(row[3]).trim() : "",
        sessionId: row[4] ? String(row[4]).trim() : ""
      }))
      .sort((a, b) => a.timestamp - b.timestamp);

    Logger.log(`Found ${agentEntries.length} log entries for this agent.`);

    if (agentEntries.length > 0) {
      let lastStartWork = null;
      for (let i = agentEntries.length - 1; i >= 0; i--) {
        if (agentEntries[i].action === "Start Work") {
          lastStartWork = agentEntries[i];
          break;
        }
        if (agentEntries[i].action === "End Work") {
          Logger.log("Found a recent 'End Work' record. Agent is not working.");
          return state; // Agent is not working
        }
      }

      if (lastStartWork) {
        Logger.log(`Active session found: ${lastStartWork.sessionId}`);
        state.isWorking = true;
        state.currentSessionId = lastStartWork.sessionId;

        let totalBreakMs = 0;
        let totalMeetingMs = 0;
        let lastBreakStart = null;
        let lastMeetingStart = null;
        let lastAction = "";

        const sessionEntries = agentEntries.filter(e => e.sessionId === state.currentSessionId);
        state.workSessionActualStartTimeISO = sessionEntries[0].timestamp.toISOString();

        sessionEntries.forEach(entry => {
          if (entry.action === "Start Break") lastBreakStart = entry.timestamp;
          if (entry.action === "End Break" && lastBreakStart) {
            totalBreakMs += (entry.timestamp.getTime() - lastBreakStart.getTime());
            lastBreakStart = null;
          }
          if (entry.action === "Start Meeting") lastMeetingStart = entry.timestamp;
          if (entry.action === "End Meeting" && lastMeetingStart) {
            totalMeetingMs += (entry.timestamp.getTime() - lastMeetingStart.getTime());
            lastMeetingStart = null;
          }
          lastAction = entry.action;
        });

        state.totalCompletedBreakDurationInSessionSeconds = Math.round(totalBreakMs / 1000);
        state.totalCompletedMeetingDurationInSessionSeconds = Math.round(totalMeetingMs / 1000);

        if (lastAction === "Start Break") {
          state.isOnBreak = true;
          state.currentBreakStartTimeISO = lastBreakStart.toISOString();
        }
        if (lastAction === "Start Meeting") {
          state.isInMeeting = true;
          state.currentMeetingStartTimeISO = lastMeetingStart.toISOString();
        }
      }
    }

    // --- Part 2: Determine currently open cases ---
    const caseLogSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.CASE_LOG);
    if (caseLogSheet) {
      Logger.log("CaseLog sheet found. Processing open cases.");
      const caseLogAllData = caseLogSheet.getDataRange().getValues();
      const agentAllCaseEvents = caseLogAllData
        .filter(row => row[1] && String(row[1]).trim().toLowerCase() === agentEmail.toLowerCase() && row[3])
        .map(row => ({
          caseId: String(row[3]).trim(),
          action: row[4] ? String(row[4]).trim() : ""
        }));

      const casesStatusMap = new Map();
      agentAllCaseEvents.forEach(event => {
        let status = casesStatusMap.get(event.caseId) || {};
        if (event.action === "Start Case" || event.action === "Start Returned Case") {
          status = { isFinished: false, isEscalated: false };
        }
        if (event.action === "Escalate Case") status.isEscalated = true;
        if (event.action === "Finish Case") status.isFinished = true;
        casesStatusMap.set(event.caseId, status);
      });

      casesStatusMap.forEach((status, caseId) => {
        if (!status.isFinished) {
          state.agentOpenCases.push({ caseId: caseId, isEscalated: status.isEscalated });
        }
      });
      Logger.log(`Found ${state.agentOpenCases.length} open cases for this agent.`);
    } else {
      Logger.log(`Warning: Sheet "${CONFIG.ATTENDANCE.SHEETS.CASE_LOG}" not found. Cannot determine open cases.`);
    }

  } catch (e) {
    Logger.log(`CRITICAL ERROR in _determineCurrentAgentState for ${agentEmail}: ${e.toString()} at stack: ${e.stack}`);
  }

  Logger.log("--- Finished _determineCurrentAgentState ---");
  return state;
}

function getAgentName_(email) {
  if (!email) return "";
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const agentsSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENTS);
    if (!agentsSheet) { return email.split('@')[0]; }
    const data = agentsSheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] && data[i][0].toString().trim().toLowerCase() === email.trim().toLowerCase()) {
        return data[i][1] || email.split('@')[0];
      }
    }
  } catch (e) { Logger.log(`Error in getAgentName_ for ${email}: ${e.toString()}`); }
  return email.split('@')[0];
}

function getActiveUserEmailForDisplay() {
  try { return Session.getActiveUser().getEmail(); }
  catch (e) { return null; }
}

// =================================================================================
// --- MANAGER-FACING FUNCTIONS ---
// =================================================================================

/**
 * Fetches all correction requests that are 'Waiting to be Approved' for the manager view.
 */
function getPendingApprovalRequests() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.REQUESTS);
    if (!sheet) return [];

    const allData = sheet.getDataRange().getValues();
    allData.shift();
    const pendingRequests = [];

    allData.forEach((row, index) => {
      const status = row[5];
      if (String(status).trim().toLowerCase() === 'waiting to be approved') {
        const rowNumber = index + 2;

        const formatDate = (dateValue) => {
            // --- CHANGE IS HERE ---
            // Send the full ISO string to preserve milliseconds
            return dateValue instanceof Date ? dateValue.toISOString() : dateValue;
        };

        pendingRequests.push({
          rowNumber: rowNumber,
          agent: row[0],
          originalTimestamp: formatDate(row[1]),
          originalAction: row[2],
          sessionId: row[3],
          requestedTimestamp: formatDate(row[7]),
          reason: row[4]
        });
      }
    });
    return pendingRequests;
  } catch (e) {
    console.error("getPendingApprovalRequests Error: " + e.toString());
    throw new Error("Could not fetch approval requests. " + e.message);
  }
}


/**
 * Applies a manager-approved correction to the AgentLog and updates the request status.
 * @param {number} requestRowNumber The row number of the request in the 'Requests' sheet.
 * @returns {string} A success message.
 */
function applyCorrection(requestRowNumber) {
  try {
    const managerEmail = Session.getActiveUser().getEmail();

    // --- Step 1: Get the request details from the Requests sheet ---
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const requestsSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.REQUESTS);
    if (!requestsSheet) throw new Error("Requests sheet not found.");

    const requestData = requestsSheet.getRange(requestRowNumber, 1, 1, 8).getValues()[0];
    const agentEmail = requestData[0];
    const originalTimestamp = new Date(requestData[1]);
    const originalAction = requestData[2];
    const correctedTimestamp = new Date(requestData[7]); // The new timestamp is in column H

    if (isNaN(correctedTimestamp.getTime())) {
      throw new Error("Invalid corrected date format in the request.");
    }

    // --- Step 2: Find and update the original entry in the AgentLog ---
    const agentLogSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    if (!agentLogSheet) throw new Error("AgentLog sheet not found.");

    const logData = agentLogSheet.getDataRange().getValues();
    let rowUpdated = false;
    for (let i = 1; i < logData.length; i++) {
      const row = logData[i];
      const rowTimestamp = new Date(row[0]);
      const rowEmail = row[1];
      const rowAction = row[3];

      // Find the specific row by matching email, action, and the exact original timestamp
      if (rowEmail === agentEmail && rowAction === originalAction && rowTimestamp.getTime() === originalTimestamp.getTime()) {
        agentLogSheet.getRange(i + 1, 1).setValue(correctedTimestamp); // Update Timestamp in Column A
        rowUpdated = true;
        break;
      }
    }

    if (!rowUpdated) {
      throw new Error("Could not find the original log entry to update. It may have been modified already.");
    }

    // --- Step 3: Update the request status to show it's completed ---
    requestsSheet.getRange(requestRowNumber, 6).setValue("Approved"); // Status in Column F (CORRECTED from "Applied")
    requestsSheet.getRange(requestRowNumber, 7).setValue(managerEmail); // Reviewed By in Column G

    return `Correction for ${agentEmail} has been successfully applied.`;

  } catch (e) {
    Logger.log("Error in applyCorrection: " + e.toString());
    throw new Error("Failed to apply correction. " + e.message);
  }
}



/**
 * Updates the status of a specific request in the sheet.
 * @param {number} rowNumber The actual row number in the sheet to update.
 * @param {string} newStatus The new status, e.g., "Approved" or "Denied".
 * @returns {string} A success message.
 */
function updateRequestStatus(rowNumber, newStatus) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.REQUESTS);
    if (!sheet) {
      throw new Error("Sheet 'Requests' not found.");
    }

    const managerEmail = Session.getActiveUser().getEmail();

    // Update the 'Approval Type' column (E) and 'By who' column (F)
    sheet.getRange(rowNumber, 5).setValue(newStatus);
    sheet.getRange(rowNumber, 6).setValue(managerEmail);

    return `Request #${rowNumber} has been successfully updated to '${newStatus}'.`;

  } catch (e) {
    console.error("updateRequestStatus Error: " + e.toString());
    throw new Error("Failed to update the request status. " + e.message);
  }
}


// =================================================================================
// --- REPORTING FUNCTIONS ---
// =================================================================================

/**
 * Gets a specific agent's completed cases for the day from the Production sheet.
 */
function getAgentSummaryFromAvailableCases(agentEmail, dateStr) {
  if (!agentEmail || !dateStr) return [];

  try {
    const targetDate = new Date(dateStr);
    const dayStart = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
    const dayEnd = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), 23, 59, 59, 999);

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const casesSheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!casesSheet) throw new Error(`Sheet "${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}" not found.`);

    const data = casesSheet.getDataRange().getValues();
    const headers = data.shift().map(h => h.toString().trim().toLowerCase());

    const emailCol = headers.indexOf("useremail");
    const caseIdCol = headers.indexOf("main task id");
    const accountNameCol = headers.indexOf("account name");
    const statusCol = headers.indexOf("status");
    const startTimeCol = headers.indexOf("main task start date/time");
    const endTimeCol = headers.indexOf("main task end date/time");

    if ([emailCol, caseIdCol, endTimeCol].includes(-1)) {
      throw new Error("Required columns (useremail, main task id, main task end date/time) not found in " + CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES + " sheet.");
    }

    const agentCases = data.filter(row => {
      const rowAgentEmail = (row[emailCol] || "").toString().trim().toLowerCase();
      if (rowAgentEmail !== agentEmail.toLowerCase()) return false;

      const endTime = row[endTimeCol] ? new Date(row[endTimeCol]) : null;
      return endTime && !isNaN(endTime.getTime()) && endTime >= dayStart && endTime <= dayEnd;
    }).map(row => {
      const startTime = startTimeCol !== -1 && row[startTimeCol] ? new Date(row[startTimeCol]) : null;
      const endTime = new Date(row[endTimeCol]);
      let durationSeconds = null;
      if (startTime && !isNaN(startTime.getTime())) {
        durationSeconds = Math.round((endTime.getTime() - startTime.getTime()) / 1000);
      }
      return {
        caseId: row[caseIdCol],
        accountName: accountNameCol > -1 ? row[accountNameCol] : 'N/A',
        startTimeISO: startTime ? startTime.toISOString() : null,
        finishTimeISO: endTime.toISOString(),
        durationSeconds: durationSeconds,
        status: statusCol > -1 ? row[statusCol] : 'N/A'
      };
    });

    return agentCases;
  } catch (e) {
    Logger.log(`Error in getAgentSummaryFromAvailableCases: ${e.message}`);
    throw e;
  }
}

/**
 * A fast function that gets the real-time status of agents for the "Active Agents" box.
 */
function getActiveAgentStatuses() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const agentsSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENTS);
    if (!agentsSheet) throw new Error(`Sheet "${CONFIG.ATTENDANCE.SHEETS.AGENTS}" not found.`);
    const agentList = agentsSheet.getRange("A2:B" + agentsSheet.getLastRow()).getValues();

    const agentLogSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    if (!agentLogSheet) return [];

    const agentLogData = agentLogSheet.getDataRange().getValues();

    const lastActions = new Map();
    // Iterate backwards for efficiency
    for (let i = agentLogData.length - 1; i >= 1; i--) {
      const row = agentLogData[i];
      const email = (row[1] || "").toString().trim().toLowerCase();
      // Once we find the latest action for an agent, we don't need to look for them again
      if (email && !lastActions.has(email)) {
        lastActions.set(email, { action: row[3] });
      }
    }

    return agentList.map(row => {
      const email = row[0];
      const name = row[1] || (email ? email.split('@')[0] : '');
      if (!email) return null;

      const lastState = lastActions.get(email.toLowerCase());
      if (lastState && lastState.action !== 'End Work') {
        let statusDetail = "Working";
        if (lastState.action === "Start Break") statusDetail = "On Break";
        else if (lastState.action === "Start Meeting") statusDetail = "In Meeting";
        return { agentName: name, statusDetail: statusDetail };
      }
      return null;
    }).filter(Boolean); // Remove null entries
  } catch (e) {
    Logger.log(`Error in getActiveAgentStatuses: ${e.message}`);
    return [{ agentName: "Error", statusDetail: e.message }];
  }
}

/**
 * Gets attendance data for the initial manager dashboard load.
 */
function getManagerAttendanceSummary(startDateStr, endDateStr) {
  if (!endDateStr) endDateStr = startDateStr;
  const rangeStart = new Date(startDateStr);
  rangeStart.setHours(0, 0, 0, 0);
  const rangeEnd = new Date(endDateStr);
  rangeEnd.setHours(23, 59, 59, 999);
  try {
    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const agentsSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENTS);
    if (!agentsSheet) throw new Error(`Sheet "${CONFIG.ATTENDANCE.SHEETS.AGENTS}" not found.`);
    const agentList = agentsSheet.getRange("A2:A" + agentsSheet.getLastRow()).getValues().flat().filter(Boolean);

    const agentLogSheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    const logData = agentLogSheet ? agentLogSheet.getDataRange().getValues() : [];

    const logsByAgent = {};
    logData.slice(1).forEach(row => {
      const email = (row[1] || "").toString().trim().toLowerCase();
      const entryDate = new Date(row[0]);
      if (email && entryDate >= rangeStart && entryDate <= rangeEnd) {
        if (!logsByAgent[email]) logsByAgent[email] = [];
        logsByAgent[email].push({ timestamp: entryDate, action: String(row[3]).trim() });
      }
    });

    return agentList.map(agentEmail => {
      const email = agentEmail.toLowerCase();
      const summary = {
        agentEmail: agentEmail,
        agentName: getAgentName_(agentEmail), // Uses helper function
        totalWorkDurationSeconds: 0,
        totalBreakDurationSeconds: 0,
        totalMeetingDurationSeconds: 0,
      };

      const agentEntries = logsByAgent[email] || [];
      if (agentEntries.length === 0) return summary;
      agentEntries.sort((a, b) => a.timestamp - b.timestamp);

      let sessionWorkMs = 0, sessionBreakMs = 0, sessionMeetingMs = 0;
      let activityStartTime = null, currentActivityType = null;

      for (const entry of agentEntries) {
        if (activityStartTime) {
          const duration = entry.timestamp.getTime() - activityStartTime.getTime();
          if (currentActivityType === "WORK") sessionWorkMs += duration;
          else if (currentActivityType === "BREAK") sessionBreakMs += duration;
          else if (currentActivityType === "MEETING") sessionMeetingMs += duration;
        }
        if (entry.action.includes("Start")) {
          activityStartTime = entry.timestamp;
          if (entry.action === "Start Work") currentActivityType = "WORK";
          else if (entry.action === "Start Break") currentActivityType = "BREAK";
          else if (entry.action === "Start Meeting") currentActivityType = "MEETING";
        } else if (entry.action.includes("End")) {
          if (entry.action === "End Break" || entry.action === "End Meeting") {
            activityStartTime = entry.timestamp;
            currentActivityType = "WORK";
          } else if (entry.action === "End Work") {
            activityStartTime = null;
            currentActivityType = null;
          }
        }
      }

      summary.totalWorkDurationSeconds = Math.round(sessionWorkMs / 1000);
      summary.totalBreakDurationSeconds = Math.round(sessionBreakMs / 1000);
      summary.totalMeetingDurationSeconds = Math.round(sessionMeetingMs / 1000);
      return summary;
    });
  } catch (e) {
    Logger.log("Error in getManagerAttendanceSummary: " + e.toString());
    return [];
  }
}

/**
 * The "heavy lifter" function called ON-DEMAND to get detailed case logs.
 */
function getAgentCasesForDateRange(agentEmail, startDateStr, endDateStr) {
  if (!agentEmail || !startDateStr) return [];
  if (!endDateStr) endDateStr = startDateStr;

  try {
    const rangeStart = new Date(startDateStr);
    rangeStart.setHours(0, 0, 0, 0);
    const rangeEnd = new Date(endDateStr);
    rangeEnd.setHours(23, 59, 59, 999);

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const casesSheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!casesSheet) throw new Error(`Sheet "${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}" not found.`);

    const data = casesSheet.getDataRange().getValues();
    if (data.length < 1) return [];

    const headers = data.shift().map(h => h.toString().trim().toLowerCase());
    const emailCol = headers.indexOf("useremail");
    const caseIdCol = headers.indexOf("main task id");
    const accountNameCol = headers.indexOf("account name");
    const statusCol = headers.indexOf("status");
    const startTimeCol = headers.indexOf("main task start date/time");
    const endTimeCol = headers.indexOf("main task end date/time");

    if ([emailCol, caseIdCol, startTimeCol, endTimeCol, accountNameCol].includes(-1)) {
      throw new Error("A core column (like useremail, main task id, account name, or a date) was not found.");
    }

    const agentCases = [];
    data.forEach((row) => {
      const rowAgentEmail = (row[emailCol] || "").toString().trim().toLowerCase();
      if (rowAgentEmail === agentEmail.toLowerCase()) {
        const startTime = row[startTimeCol] ? new Date(row[startTimeCol]) : null;
        const endTime = row[endTimeCol] ? new Date(row[endTimeCol]) : null;

        if (startTime && endTime && !isNaN(startTime.getTime()) && !isNaN(endTime.getTime()) && startTime < rangeEnd && endTime > rangeStart) {
          agentCases.push({
            caseId: row[caseIdCol],
            accountName: row[accountNameCol] || "N/A",
            startTime: startTime,
            endTime: endTime,
            status: row[statusCol] || "N/A",
            idleTimeBeforeThisCaseSeconds: 0
          });
        }
      }
    });

    agentCases.sort((a, b) => a.startTime - b.startTime);

    return agentCases.map((currentCase, index, array) => {
      if (index > 0) {
        const previousCase = array[index - 1];
        const idleTimeMs = currentCase.startTime.getTime() - previousCase.endTime.getTime();
        currentCase.idleTimeBeforeThisCaseSeconds = idleTimeMs > 0 ? Math.round(idleTimeMs / 1000) : 0;
      }
      return {
        caseId: currentCase.caseId,
        accountName: currentCase.accountName,
        startTimeISO: currentCase.startTime.toISOString(),
        endTimeISO: currentCase.endTime.toISOString(),
        status: currentCase.status,
        idleTimeBeforeThisCaseSeconds: currentCase.idleTimeBeforeThisCaseSeconds
      };
    });

  } catch (e) {
    Logger.log(`Error in getAgentCasesForDateRange: ${e.message}`);
    return [];
  }
}

/**
 * Calculates and ranks agent performance for a leaderboard.
 */
function getLeaderboardData(startDateStr, endDateStr) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const caseSheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!caseSheet) throw new Error(`Required sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);

    const startDate = new Date(startDateStr);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(endDateStr);
    endDate.setHours(23, 59, 59, 999);

    const agentData = {};

    const caseValues = caseSheet.getDataRange().getValues();
    const headers = caseValues.shift().map(h => h.toString().trim().toLowerCase());

    // Define column names to look for
    const COLS = {
        EMAIL: "useremail",
        STATUS: "status",
        START_TIME: "main task start date/time",
        END_TIME: "main task end date/time",
        PAUSE: "stored pause duration",
        ESCALATION: "stored escalation duration"
    };

    // Map header names to their column index
    const headerMap = {};
    Object.keys(COLS).forEach(key => {
        headerMap[key] = headers.indexOf(COLS[key]);
    });

    caseValues.forEach(row => {
      const endTimeValue = row[headerMap.END_TIME];
      if (!endTimeValue) return;
      const endTime = new Date(endTimeValue);
      const caseStatus = row[headerMap.STATUS];

      if (caseStatus === 'Completed' && endTime >= startDate && endTime <= endDate) {
        const agentEmail = row[headerMap.EMAIL];
        if (!agentEmail) return;

        if (!agentData[agentEmail]) {
          agentData[agentEmail] = { name: agentEmail, totalCases: 0, totalHandlingTime: 0 };
        }

        const startTime = new Date(row[headerMap.START_TIME]);
        // Note: Durations in Sheets are fractions of a day. Convert to seconds.
        const pauseDuration = (parseFloat(row[headerMap.PAUSE]) || 0) * 86400;
        const escalationDuration = (parseFloat(row[headerMap.ESCALATION]) || 0) * 86400;
        const grossDuration = (endTime - startTime) / 1000; // in seconds

        const netHandlingTime = grossDuration - pauseDuration - escalationDuration;
        agentData[agentEmail].totalCases++;
        agentData[agentEmail].totalHandlingTime += netHandlingTime > 0 ? netHandlingTime : 0;
      }
    });

    const leaderboard = Object.values(agentData).map(agent => {
      const avgHandlingTime = agent.totalCases > 0 ? agent.totalHandlingTime / agent.totalCases : 0;
      return {
        agentName: agent.name,
        totalCases: agent.totalCases,
        avgHandlingTime: avgHandlingTime,
      };
    });

    leaderboard.sort((a, b) => b.totalCases - a.totalCases);
    return leaderboard.map((agent, index) => ({ ...agent, rank: index + 1 }));

  } catch (e) {
    console.error("getLeaderboardData Error: " + e.toString());
    throw new Error("Could not generate leaderboard data. Check script logs for details. " + e.message);
  }
}


/**
 * Fetches all completed case details for a specific agent within a date range.
 */
function getCaseDetailsForAgent(agentEmail, startDateStr, endDateStr) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const caseSheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!caseSheet) throw new Error(`Required sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);

    const startDate = new Date(startDateStr);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(endDateStr);
    endDate.setHours(23, 59, 59, 999);

    const caseDetails = [];

    const caseValues = caseSheet.getDataRange().getValues();
    const headers = caseValues.shift().map(h => h.toString().trim().toLowerCase());

    const COLS = {
        EMAIL: "useremail",
        STATUS: "status",
        START_TIME: "main task start date/time",
        END_TIME: "main task end date/time",
        PAUSE: "stored pause duration",
        ESCALATION: "stored escalation duration",
        CASE_ID: "main task id",
        ACCOUNT_NAME: "account name"
    };

    const headerMap = {};
    Object.keys(COLS).forEach(key => {
        headerMap[key] = headers.indexOf(COLS[key]);
    });

    caseValues.forEach((row, index) => {
      const caseAgent = row[headerMap.EMAIL];
      if (!caseAgent || caseAgent.toLowerCase() !== agentEmail.toLowerCase()) return;

      const endTimeValue = row[headerMap.END_TIME];
      if (!endTimeValue) return;
      const endTime = new Date(endTimeValue);
      const caseStatus = row[headerMap.STATUS];

      if (caseStatus === 'Completed' && endTime >= startDate && endTime <= endDate) {
        const startTime = new Date(row[headerMap.START_TIME]);
        const pauseDuration = (parseFloat(row[headerMap.PAUSE]) || 0) * 86400; // in seconds
        const escalationDuration = (parseFloat(row[headerMap.ESCALATION]) || 0) * 86400; // in seconds

        const grossDuration = (endTime - startTime) / 1000; // in seconds
        const netHandlingTime = grossDuration - pauseDuration - escalationDuration;

        caseDetails.push({
          caseId: row[headerMap.CASE_ID],
          accountName: row[headerMap.ACCOUNT_NAME],
          handlingTime: netHandlingTime > 0 ? netHandlingTime : 0,
          startTime: startTime.toISOString(),
          endTime: endTime.toISOString(),
          pauseDuration: pauseDuration,
          escalationDuration: escalationDuration,
          uniqueId: `case-detail-${index}`
        });
      }
    });

    return caseDetails;

  } catch (e) {
    console.error("getCaseDetailsForAgent Error: " + e.toString());
    throw new Error("Could not fetch case details. " + e.message);
  }
}

/**
 * Gets unique values for all specified filter columns to populate the dashboard UI.
 * NOTE: Adjust the header names in the 'headerNames' object if they differ in your sheet.
 */
function getProductionFilterOptions() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!sheet) {
      throw new Error(`Sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);
    }
    const data = sheet.getDataRange().getValues();
    const headers = data.shift().map(h => String(h).trim().toLowerCase());

    // --- CONFIGURATION: Match these names to your sheet's column headers ---
    const headerNames = {
      status: "status",
      country: "country",
      category: "category",
      taskType: "task type", // Assumed header name
      retailerType: "retailer provider type",
      slaMissedReason: "sla missed reason" // Assumed header name
    };
    // --------------------------------------------------------------------

    const colIndices = {
      status: headers.indexOf(headerNames.status),
      country: headers.indexOf(headerNames.country),
      category: headers.indexOf(headerNames.category),
      taskType: headers.indexOf(headerNames.taskType),
      retailerType: headers.indexOf(headerNames.retailerType),
      slaMissedReason: headers.indexOf(headerNames.slaMissedReason),
    };

    const uniqueValues = {
      statuses: new Set(),
      markets: new Set(),
      categories: new Set(),
      taskTypes: new Set(),
      retailerTypes: new Set(),
      slaMissedReasons: new Set(),
    };

    data.forEach(row => {
      if (colIndices.status !== -1 && row[colIndices.status]) uniqueValues.statuses.add(row[colIndices.status]);
      if (colIndices.country !== -1 && row[colIndices.country]) uniqueValues.markets.add(row[colIndices.country]);
      if (colIndices.category !== -1 && row[colIndices.category]) uniqueValues.categories.add(row[colIndices.category]);
      if (colIndices.taskType !== -1 && row[colIndices.taskType]) uniqueValues.taskTypes.add(row[colIndices.taskType]);
      if (colIndices.retailerType !== -1 && row[colIndices.retailerType]) uniqueValues.retailerTypes.add(row[colIndices.retailerType]);
      if (colIndices.slaMissedReason !== -1 && row[colIndices.slaMissedReason]) uniqueValues.slaMissedReasons.add(row[colIndices.slaMissedReason]);
    });

    return {
      statuses: Array.from(uniqueValues.statuses).sort(),
      markets: Array.from(uniqueValues.markets).sort(),
      categories: Array.from(uniqueValues.categories).sort(),
      taskTypes: Array.from(uniqueValues.taskTypes).sort(),
      retailerTypes: Array.from(uniqueValues.retailerTypes).sort(),
      slaMissedReasons: Array.from(uniqueValues.slaMissedReasons).sort(),
    };

  } catch (e) {
    console.error("getProductionFilterOptions Error: " + e.toString());
    return { statuses: [], markets: [], categories: [], taskTypes: [], retailerTypes: [], slaMissedReasons: [] };
  }
}


function getProductionReport(filters) {
  try {
    const {
      startDateStr, endDateStr,
      drillDownStatus, drillDownMarket, drillDownTat,
      // New filter values from the front-end
      selectedStatus, selectedMarket, selectedCategory,
      selectedTaskType, selectedRetailerType, selectedSlaReason
    } = filters;

    // ... (blankSummary object remains the same)
    const blankSummary = {
      totalCounts: {}, marketCounts: {}, tatCounts: {},
      menuComplexity: { marketData: {}, grandTotal: {} },
      ahtByMonth: { marketData: {}, grandTotal: {} },
      ahtByRetailer: { marketData: {}, grandTotal: {} },
      ahtByCategory: { categoryData: {}, grandTotal: {} },
      tatBucket: { marketData: {}, grandTotal: {} },
      monthList: [], retailerTypeList: [], categoryList: []
    };

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!sheet) throw new Error(`Sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);

    const startDate = new Date(startDateStr);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(endDateStr);
    endDate.setHours(23, 59, 59, 999);

    const rawData = sheet.getDataRange().getValues();
    const headers = rawData.shift().map(h => h.toString().trim());

    const headerMap = {
      // ... (existing headerMap remains the same)
      country: headers.indexOf("Country"),
      status: headers.indexOf("Status"),
      category: headers.indexOf("Category"),
      startTime: headers.indexOf("Main Task Start Date/Time"),
      endTime: headers.indexOf("Main Task End Date/Time"),
      escalation: headers.indexOf("Stored Escalation Duration"),
      aht: headers.indexOf("Stored Agent Handling Time"),
      totalDishes: headers.indexOf("Total No. of dishes"),
      mainDishesPhotos: headers.indexOf("No of Valid Photos for Main dishes (Exlcuding Extras, drinks, sides etc.)"),
      totalOptions: headers.indexOf("Total no. of options"),
      totalOptionGroups: headers.indexOf("Total no. of option Groups"),
      retailerType: headers.indexOf("Retailer Provider Type"),
      // Add new headers for filtering if they aren't already here
      taskType: headers.indexOf("Task Type"),
      slaMissedReason: headers.indexOf("SLA Missed Reason")
    };

    // --- NEW: CENTRAL FILTERING LOGIC (MULTI-SELECT ENABLED) ---
const dataInDateRange = rawData.filter(row => {
    // 1. Date Filter (mandatory)
    const status = row[headerMap.status];
    const dateToCheck = (status === 'Completed' || status === 'Finished') ? row[headerMap.endTime] : row[headerMap.startTime];
    const isDateValid = dateToCheck instanceof Date && dateToCheck >= startDate && dateToCheck <= endDate;
    if (!isDateValid) return false;

    // 2. Dropdown Filters (handle arrays; an empty array means "All")
    const statusMatch = !selectedStatus || selectedStatus.length === 0 || selectedStatus.includes(row[headerMap.status]);
    const marketMatch = !selectedMarket || selectedMarket.length === 0 || selectedMarket.includes(row[headerMap.country]);
    const categoryMatch = !selectedCategory || selectedCategory.length === 0 || selectedCategory.includes(row[headerMap.category]);
    const taskTypeMatch = !selectedTaskType || selectedTaskType.length === 0 || selectedTaskType.includes(row[headerMap.taskType]);
    const retailerTypeMatch = !selectedRetailerType || selectedRetailerType.length === 0 || selectedRetailerType.includes(row[headerMap.retailerType]);
    const slaReasonMatch = !selectedSlaReason || selectedSlaReason.length === 0 || selectedSlaReason.includes(row[headerMap.slaMissedReason]);

    return statusMatch && marketMatch && categoryMatch && taskTypeMatch && retailerTypeMatch && slaReasonMatch;
});
// --- END OF NEW LOGIC ---

    // ... (The rest of the function remains identical, as it now operates on the pre-filtered 'dataInDateRange' array)
    // ... from 'const totalCounts = ...' all the way to the final 'return { summary: summary, ... }'

    // NOTE: The entire aggregation and drilldown logic from the previous version of the function
    // should be pasted here without any changes.

    const totalCounts = { "Cancelled": 0, "Completed": 0, "Escalated": 0, "In Progress": 0, "Not Started": 0, "Task Paused": 0, "GrandTotal": 0 };
    const marketCounts = {};
    const tatCounts = {};
    const menuComplexityAgg = {};
    const ahtByMonthAgg = {};
    const ahtByRetailerAgg = {};
    const ahtByCategoryAgg = {};
    const tatBucketAgg = {};
    const monthSet = new Set();
    const retailerTypeSet = new Set();
    const categorySet = new Set();
    const now = new Date();

    dataInDateRange.forEach(row => {
      const country = row[headerMap.country];
      const status = row[headerMap.status];
      const category = row[headerMap.category];
      const startTime = row[headerMap.startTime];
      const endTime = row[headerMap.endTime];
      const retailerType = row[headerMap.retailerType];
      
      let ahtInSeconds = 0;
      const ahtRawValue = row[headerMap.aht];
      if (ahtRawValue instanceof Date) { ahtInSeconds = (ahtRawValue.getHours() * 3600) + (ahtRawValue.getMinutes() * 60) + ahtRawValue.getSeconds(); }
      else if (!isNaN(parseFloat(ahtRawValue))) { ahtInSeconds = parseFloat(ahtRawValue) * 86400; }

      if (category && ahtInSeconds > 0) {
          categorySet.add(category);
          if (!ahtByCategoryAgg[category]) {
              ahtByCategoryAgg[category] = { sum: 0, count: 0 };
          }
          ahtByCategoryAgg[category].sum += ahtInSeconds;
          ahtByCategoryAgg[category].count++;
      }

      if (country && endTime instanceof Date) {
        if (ahtInSeconds > 0) { const year = endTime.getFullYear(); const month = (endTime.getMonth() + 1).toString().padStart(2, '0'); const monthKey = `${year}-${month}`; monthSet.add(monthKey); if (!ahtByMonthAgg[country]) ahtByMonthAgg[country] = {}; if (!ahtByMonthAgg[country][monthKey]) ahtByMonthAgg[country][monthKey] = { sum: 0, count: 0 }; ahtByMonthAgg[country][monthKey].sum += ahtInSeconds; ahtByMonthAgg[country][monthKey].count++; }
        if (ahtInSeconds > 0 && retailerType) { retailerTypeSet.add(retailerType); if (!ahtByRetailerAgg[country]) ahtByRetailerAgg[country] = {}; if (!ahtByRetailerAgg[country][retailerType]) ahtByRetailerAgg[country][retailerType] = { sum: 0, count: 0 }; ahtByRetailerAgg[country][retailerType].sum += ahtInSeconds; ahtByRetailerAgg[country][retailerType].count++; }
      }
      if (country && startTime instanceof Date) { const effectiveEndTime = (endTime instanceof Date) ? endTime : now; const durationHours = (effectiveEndTime.getTime() - startTime.getTime()) / 3600000; if (!tatBucketAgg[country]) tatBucketAgg[country] = { under24: 0, between24and30: 0, between30and48: 0, over48: 0, total: 0 }; if (durationHours < 24) tatBucketAgg[country].under24++; else if (durationHours >= 24 && durationHours < 30) tatBucketAgg[country].between24and30++; else if (durationHours >= 30 && durationHours < 48) tatBucketAgg[country].between30and48++; else tatBucketAgg[country].over48++; tatBucketAgg[country].total++; }
      if (totalCounts.hasOwnProperty(status)) totalCounts[status]++;
      if (country) { if (!marketCounts[country]) marketCounts[country] = { "Cancelled": 0, "Completed": 0, "Escalated": 0, "In Progress": 0, "Not Started": 0, "Task Paused": 0 }; if (marketCounts[country].hasOwnProperty(status)) marketCounts[country][status]++; }
      if ((status === 'Completed' || status === 'Finished') && startTime instanceof Date && endTime instanceof Date) { const escalationMs = (parseFloat(row[headerMap.escalation]) || 0) * 86400000; const netDurationHours = (endTime.getTime() - startTime.getTime() - escalationMs) / 3600000; if (!tatCounts[country]) tatCounts[country] = { adhered: 0, missed: 0 }; if (netDurationHours < 24) tatCounts[country].adhered++; else tatCounts[country].missed++; }
      if (country) { if (!menuComplexityAgg[country]) menuComplexityAgg[country] = { aht: { sum: 0, count: 0 }, totalDishes: { sum: 0, count: 0 }, mainDishesPhotos: { sum: 0, count: 0 }, totalOptions: { sum: 0, count: 0 }, totalOptionGroups: { sum: 0, count: 0 } }; const safeAdd = (metric, value, isSeconds = false) => { const num = parseFloat(value); if (!isNaN(num)) { menuComplexityAgg[country][metric].sum += (isSeconds ? value : num); menuComplexityAgg[country][metric].count++; } }; if (ahtInSeconds > 0) safeAdd('aht', ahtInSeconds, true); safeAdd('totalDishes', row[headerMap.totalDishes]); safeAdd('mainDishesPhotos', row[headerMap.mainDishesPhotos]); safeAdd('totalOptions', row[headerMap.totalOptions]); safeAdd('totalOptionGroups', row[headerMap.totalOptionGroups]); }
    });
    
    totalCounts.GrandTotal = Object.values(totalCounts).reduce((a, b) => a + b, 0) - totalCounts.GrandTotal;
    const menuComplexity = {}; for (const country in menuComplexityAgg) { const agg = menuComplexityAgg[country]; menuComplexity[country] = { avgAhtSeconds: (agg.aht.count > 0) ? (agg.aht.sum / agg.aht.count) : 0, avgTotalDishes: (agg.totalDishes.count > 0) ? agg.totalDishes.sum / agg.totalDishes.count : 0, avgMainDishesPhotos: (agg.mainDishesPhotos.count > 0) ? agg.mainDishesPhotos.sum / agg.mainDishesPhotos.count : 0, avgTotalOptions: (agg.totalOptions.count > 0) ? agg.totalOptions.sum / agg.totalOptions.count : 0, avgTotalOptionGroups: (agg.totalOptionGroups.count > 0) ? agg.totalOptionGroups.sum / agg.totalOptionGroups.count : 0 }; }
    const ahtByMonth = {}; for (const country in ahtByMonthAgg) { ahtByMonth[country] = {}; for (const month in ahtByMonthAgg[country]) { const agg = ahtByMonthAgg[country][month]; if (agg.count > 0) { ahtByMonth[country][month] = (agg.sum / agg.count); } } } const monthList = Array.from(monthSet).sort();
    const ahtByRetailer = {}; for (const country in ahtByRetailerAgg) { ahtByRetailer[country] = {}; for (const rType in ahtByRetailerAgg[country]) { const agg = ahtByRetailerAgg[country][rType]; if (agg.count > 0) { ahtByRetailer[country][rType] = (agg.sum / agg.count); } } } const retailerTypeList = Array.from(retailerTypeSet).sort();
    const ahtByCategory = {}; for (const category in ahtByCategoryAgg) { const agg = ahtByCategoryAgg[category]; if (agg.count > 0) { ahtByCategory[category] = (agg.sum / agg.count); } } const categoryList = Array.from(categorySet).sort();
    const tatBucket = { marketData: tatBucketAgg };
    const complexityGrandTotalAgg = { aht: { sum: 0, count: 0 }, totalDishes: { sum: 0, count: 0 }, mainDishesPhotos: { sum: 0, count: 0 }, totalOptions: { sum: 0, count: 0 }, totalOptionGroups: { sum: 0, count: 0 } }; for (const country in menuComplexityAgg) { for (const metric in menuComplexityAgg[country]) { complexityGrandTotalAgg[metric].sum += menuComplexityAgg[country][metric].sum; complexityGrandTotalAgg[metric].count += menuComplexityAgg[country][metric].count; } } const menuComplexityGrandTotal = { avgAhtSeconds: (complexityGrandTotalAgg.aht.count > 0) ? (complexityGrandTotalAgg.aht.sum / complexityGrandTotalAgg.aht.count) : 0, avgTotalDishes: (complexityGrandTotalAgg.totalDishes.count > 0) ? (complexityGrandTotalAgg.totalDishes.sum / complexityGrandTotalAgg.totalDishes.count) : 0, avgMainDishesPhotos: (complexityGrandTotalAgg.mainDishesPhotos.count > 0) ? (complexityGrandTotalAgg.mainDishesPhotos.sum / complexityGrandTotalAgg.mainDishesPhotos.count) : 0, avgTotalOptions: (complexityGrandTotalAgg.totalOptions.count > 0) ? (complexityGrandTotalAgg.totalOptions.sum / complexityGrandTotalAgg.totalOptions.count) : 0, avgTotalOptionGroups: (complexityGrandTotalAgg.totalOptionGroups.count > 0) ? (complexityGrandTotalAgg.totalOptionGroups.sum / complexityGrandTotalAgg.totalOptionGroups.count) : 0 };
    const ahtByMonthGrandTotal = {}; monthList.forEach(month => { let monthSum = 0; let monthCount = 0; for (const country in ahtByMonthAgg) { if (ahtByMonthAgg[country][month]) { monthSum += ahtByMonthAgg[country][month].sum; monthCount += ahtByMonthAgg[country][month].count; } } ahtByMonthGrandTotal[month] = (monthCount > 0) ? (monthSum / monthCount) : 0; });
    const ahtByRetailerGrandTotal = {}; retailerTypeList.forEach(retailerType => { let retailerSum = 0; let retailerCount = 0; for (const country in ahtByRetailerAgg) { if (ahtByRetailerAgg[country][retailerType]) { retailerSum += ahtByRetailerAgg[country][retailerType].sum; retailerCount += ahtByRetailerAgg[country][retailerType].count; } } ahtByRetailerGrandTotal[retailerType] = (retailerCount > 0) ? (retailerSum / retailerCount) : 0; });
    const ahtByCategoryGrandTotalAgg = { sum: 0, count: 0 }; for (const category in ahtByCategoryAgg) { ahtByCategoryGrandTotalAgg.sum += ahtByCategoryAgg[category].sum; ahtByCategoryGrandTotalAgg.count += ahtByCategoryAgg[category].count; } const ahtByCategoryGrandTotal = { avgAhtSeconds: (ahtByCategoryGrandTotalAgg.count > 0) ? (ahtByCategoryGrandTotalAgg.sum / ahtByCategoryGrandTotalAgg.count) : 0 };
    const tatBucketGrandTotal = { under24: 0, between24and30: 0, between30and48: 0, over48: 0, total: 0 }; for (const country in tatBucketAgg) { for (const bucket in tatBucketAgg[country]) { tatBucketGrandTotal[bucket] += tatBucketAgg[country][bucket]; } } tatBucket.grandTotal = tatBucketGrandTotal;
    
    let drillDownDetails = [];
    if (filters.drillDownStatus || filters.drillDownTat) {
      drillDownDetails = dataInDateRange.filter(row => {
        const country = row[headerMap.country]; const status = row[headerMap.status]; const category = row[headerMap.category];
        if (filters.drillDownTat) { if (status !== 'Completed' && status !== 'Finished') return false; if (country !== filters.drillDownMarket) return false; const startTime = row[headerMap.startTime]; const endTime = row[headerMap.endTime]; if (!(startTime instanceof Date && endTime instanceof Date)) return false; const escalationMs = (parseFloat(row[headerMap.escalation]) || 0) * 86400000; const netDurationHours = (endTime.getTime() - startTime.getTime() - escalationMs) / 3600000; const tatStatus = netDurationHours < 24 ? "Adhered" : "Missed"; return tatStatus === filters.drillDownTat; }
        if (filters.drillDownStatus === 'TAT Bucket') { if (country !== filters.drillDownMarket) return false; const startTime = row[headerMap.startTime]; if (!(startTime instanceof Date)) return false; const effectiveEndTime = (row[headerMap.endTime] instanceof Date) ? row[headerMap.endTime] : now; const durationHours = (effectiveEndTime.getTime() - startTime.getTime()) / 3600000; const bucket = filters.subFilter; if (bucket === '<24 hours') return durationHours < 24; if (bucket === '24-30 hours') return durationHours >= 24 && durationHours < 30; if (bucket === '30-48 hours') return durationHours >= 30 && durationHours < 48; if (bucket === '>48 hours') return durationHours > 48; return false; }
        if (filters.drillDownStatus === 'AHT by Month') { if (country !== filters.drillDownMarket) return false; const endTime = row[headerMap.endTime]; if (!(endTime instanceof Date)) return false; const monthKey = `${endTime.getFullYear()}-${(endTime.getMonth() + 1).toString().padStart(2, '0')}`; return monthKey === filters.subFilter; }
        if (filters.drillDownStatus === 'AHT by Retailer') { if (country !== filters.drillDownMarket) return false; return row[headerMap.retailerType] === filters.subFilter; }
        if (filters.drillDownStatus === 'AHT by Category') { return category === filters.subFilter; }
        if (filters.drillDownStatus === 'Menu Complexity') { return country === filters.drillDownMarket; }
        const marketMatch = filters.drillDownMarket === 'All' || country === filters.drillDownMarket; return status === filters.drillDownStatus && marketMatch;
      }).map(row => {
          const record = {};
          headers.forEach((header, i) => {
              let value = row[i];
              if (header === 'Stored Agent Handling Time' && value instanceof Date) {
                  const totalSeconds = value.getHours() * 3600 + value.getMinutes() * 60 + value.getSeconds();
                  record[header] = totalSeconds / 86400.0;
              } else {
                  record[header] = (value instanceof Date) ? value.toISOString() : value;
              }
          });
          return record;
      });
    }
    const summary = { totalCounts, marketCounts, tatCounts, menuComplexity: { marketData: menuComplexity, grandTotal: menuComplexityGrandTotal }, ahtByMonth: { marketData: ahtByMonth, grandTotal: ahtByMonthGrandTotal }, ahtByRetailer: { marketData: ahtByRetailer, grandTotal: ahtByRetailerGrandTotal }, ahtByCategory: { categoryData: ahtByCategory, grandTotal: ahtByCategoryGrandTotal }, tatBucket: tatBucket, monthList, retailerTypeList, categoryList };
    return { summary: summary, details: drillDownDetails, error_message: null };

  } catch (e) {
    console.error("getProductionReport Error: " + e.toString() + "\nStack: " + e.stack);
    return { summary: blankSummary, details: [], error_message: "An unexpected error occurred: " + e.message };
  }
}








/**
 * Fetches an agent's attendance log entries for a given date range.
 */
function getAgentAttendanceLog(dateRange) {
  try {
    const agentEmail = Session.getActiveUser().getEmail();
    if (!agentEmail) throw new Error("Could not identify the current user.");

    const startDate = new Date(dateRange.startDate);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(dateRange.endDate);
    endDate.setHours(23, 59, 59, 999);

    const ss = SpreadsheetApp.openById(CONFIG.ATTENDANCE.ID);
    const sheet = ss.getSheetByName(CONFIG.ATTENDANCE.SHEETS.AGENT_LOG);
    if (!sheet) throw new Error("AgentLog sheet not found.");

    const allData = sheet.getDataRange().getValues();
    allData.shift();

    const agentLogs = allData.filter(row => {
      const rowEmail = (row[1] || "").toString().trim().toLowerCase();
      if (rowEmail !== agentEmail.toLowerCase()) return false;
      const timestamp = row[0] instanceof Date ? row[0] : new Date(row[0]);
      return timestamp >= startDate && timestamp <= endDate;
    });

    return agentLogs.map(row => {
      const timestamp = row[0] instanceof Date ? row[0] : new Date(row[0]);
      return {
        // --- CHANGE IS HERE ---
        // Send the full ISO string to preserve milliseconds
        timestamp: timestamp.toISOString(),
        action: row[3],
        sessionId: row[4]
      };
    }).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

  } catch (e) {
    Logger.log("Error in getAgentAttendanceLog: " + e.toString());
    throw new Error("Failed to retrieve attendance log. " + e.message);
  }
}

/**
 * Gets a performance summary for the agent for the current day.
 * Called by the new agent dashboard to populate scorecards.
 */
function getAgentDashboardSummary() {
  try {
    const agentEmail = Session.getActiveUser().getEmail();
    if (!agentEmail) return {};

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!sheet) throw new Error(`Sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);

    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);
    const todayEnd = new Date();
    todayEnd.setHours(23, 59, 59, 999);

    const data = sheet.getDataRange().getValues();
    const headers = data.shift().map(h => h.toString().trim().toLowerCase());

    const emailCol = headers.indexOf("useremail");
    const statusCol = headers.indexOf("status");
    const startTimeCol = headers.indexOf("main task start date/time");
    const endTimeCol = headers.indexOf("main task end date/time");

    let summary = {
      closedToday: 0,
      inProgress: 0,
      escalated: 0,
      totalHandlingTime: 0
    };

    data.forEach(row => {
      const rowEmail = (row[emailCol] || "").toString().trim().toLowerCase();
      if (rowEmail === agentEmail.toLowerCase()) {
        const status = (row[statusCol] || "").toString();
        const startTime = row[startTimeCol] instanceof Date ? row[startTimeCol] : null;

        if (startTime && startTime >= todayStart && startTime <= todayEnd) {
            if (status === 'Completed' || status === 'Finished') {
                summary.closedToday++;
                const endTime = row[endTimeCol] instanceof Date ? row[endTimeCol] : null;
                if (endTime) {
                    const durationSeconds = (endTime.getTime() - startTime.getTime()) / 1000;
                    summary.totalHandlingTime += durationSeconds > 0 ? durationSeconds : 0;
                }
            } else if (status === 'In Progress') {
                summary.inProgress++;
            } else if (status === 'Escalated') {
                summary.escalated++;
            }
        }
      }
    });

    summary.aht = summary.closedToday > 0 ? summary.totalHandlingTime / summary.closedToday : 0;

    return summary;

  } catch (e) {
    Logger.log("Error in getAgentDashboardSummary: " + e.toString());
    return { closedToday: 'Err', aht: 0, escalated: 'Err', inProgress: 'Err' };
  }
}


/**
 * Fetches, filters, sorts, and paginates cases for the Case Management page.
 * Includes a smarter, targeted search.
 */
function searchAllCases(searchTerm) {
  try {
    if (!searchTerm) {
      return [];
    }

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!sheet) throw new Error(`Sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);

    const data = sheet.getDataRange().getValues();
    const headers = data.shift();

    let records = data.map(row => {
      let record = {};
      headers.forEach((header, i) => { record[header] = row[i]; });
      return record;
    });

    const lowerCaseSearchTerm = searchTerm.toLowerCase();
    const searchableHeaders = ['Main Task ID', 'Country', 'Account Name', 'Case Title', 'Category', 'Provider Id', 'Useremail'];
    let filteredRecords = records.filter(record => {
        return searchableHeaders.some(header =>
            record[header] && String(record[header]).toLowerCase().includes(lowerCaseSearchTerm)
        );
    });

    filteredRecords.sort((a, b) => {
      const dateA = new Date(a['Menu Request Sent Date'] || 0);
      const dateB = new Date(b['Menu Request Sent Date'] || 0);
      return dateB - dateA;
    });

    const serializableRecords = filteredRecords.map(record => {
        const newRecord = {};
        for (const key in record) {
            if (record[key] instanceof Date) {
                newRecord[key] = record[key].toISOString();
            } else {
                newRecord[key] = record[key];
            }
        }
        return newRecord;
    });

    return serializableRecords;

  } catch (e) {
    Logger.log("Error in searchAllCases: " + e.toString());
    throw new Error("Failed to search cases. " + e.message);
  }
}

function getCasesByStatus(options) {
  const { status, searchTerm, limit = 20, offset = 0, country, filter } = options;
  const cache = CacheService.getScriptCache();
  const CACHE_KEY_MANIFEST = 'main_tasks_manifest';
  const CACHE_EXPIRATION = 300; // 5 minutes

  let rawData;
  const manifestJSON = cache.get(CACHE_KEY_MANIFEST);

  if (manifestJSON) {
    Logger.log("Cache HIT for manifest.");
    const manifest = JSON.parse(manifestJSON);
    const chunkKeys = manifest.keys;
    const cachedChunks = cache.getAll(chunkKeys);
    let reassembledJSON = "";
    for (const key of chunkKeys) {
      if (cachedChunks[key]) {
        reassembledJSON += cachedChunks[key];
      } else {
        Logger.log(`Cache MISS for chunk ${key}. Forcing refresh.`);
        reassembledJSON = null;
        break;
      }
    }
    if (reassembledJSON) {
      rawData = JSON.parse(reassembledJSON);
    }
  }

  if (!rawData) {
    Logger.log("Cache MISS. Acquiring lock to fetch from sheet.");
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(30000); // Wait up to 30 seconds.
      // Double check if another process populated the cache while we waited
      const manifestAfterLock = cache.get(CACHE_KEY_MANIFEST);
      if (manifestAfterLock) {
         Logger.log("Cache HIT after waiting for lock.");
         // This is a simplified re-read for brevity. The full reassembly logic is above.
         rawData = JSON.parse(cache.get(JSON.parse(manifestAfterLock).keys[0]));
      } else {
        Logger.log("Fetching from spreadsheet.");
        const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
        const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
        const data = sheet.getDataRange().getValues();
        const headers = data.shift();

        rawData = { headers: headers, data: data };

        const rawDataString = JSON.stringify(rawData);
        const CHUNK_SIZE = 90000; // 90KB, safely under the 100KB limit
        const numChunks = Math.ceil(rawDataString.length / CHUNK_SIZE);
        const chunks = {};
        const chunkKeys = [];

        for (let i = 0; i < numChunks; i++) {
          const key = `main_tasks_chunk_${i}`;
          chunkKeys.push(key);
          const start = i * CHUNK_SIZE;
          const end = start + CHUNK_SIZE;
          chunks[key] = rawDataString.substring(start, end);
        }

        const newManifest = { keys: chunkKeys, timestamp: new Date().getTime() };
        chunks[CACHE_KEY_MANIFEST] = JSON.stringify(newManifest);

        cache.putAll(chunks, CACHE_EXPIRATION);
        Logger.log(`Populated cache with ${numChunks} chunks.`);
      }
    } catch (e) {
      Logger.log("Lock timeout or error during fetch: " + e.toString());
      throw new Error("Server is busy fetching new data, please try again in a moment.");
    } finally {
      lock.releaseLock();
    }
  }

  // --- Start processing with the (now populated) rawData ---
  const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID); // Needed for logs
  const openPauses = getOpenLogs_(ss, CONFIG.PRODUCTION.SHEETS.PAUSING_LOGS, 'Related Case ID', 'Pause Start Time', 'Paused End Time');
  const openEscalations = getOpenLogs_(ss, CONFIG.PRODUCTION.SHEETS.ESCALATION_LOGS, 'Related Case ID', 'Escalation Start Time', 'Escalated End Time');

  const headers = rawData.headers;
  const caseIdHeader = 'Main Task ID';
  const ignoredHeaders = ['Pause Time', 'Pause End Time', 'Escalated Start Time', 'Escalated End Time'];
  const userEmail = (filter === 'my') ? Session.getActiveUser().getEmail() : null;

  const records = rawData.data.map(row => {
    let record = {};
    headers.forEach((header, i) => { if (!ignoredHeaders.includes(header)) { record[header] = row[i]; } });
    const caseId = record[caseIdHeader];
    if (caseId) {
      if (openPauses.has(caseId)) { record['Pause Start Time'] = openPauses.get(caseId); record['Paused End Time'] = ''; }
      if (openEscalations.has(caseId)) { record['Escalated Start Time'] = openEscalations.get(caseId); record['Escalated End Time'] = ''; }
    }
    return record;
  });

  // Perform filtering
  const filteredRecords = records.filter(record => {
    if (status !== 'All') {
      const hasOpenPause = record['Pause Start Time'] && !record['Paused End Time'];
      const hasOpenEscalation = record['Escalated Start Time'] && !record['Escalated End Time'];
      let effectiveStatus = record.Status;
      if (hasOpenPause) effectiveStatus = 'Task Paused';
      else if (hasOpenEscalation) effectiveStatus = 'Escalated';
      if (effectiveStatus !== status) return false;
    }
    if (country && record.Country !== country) return false;
    if (userEmail && (!record.Useremail || record.Useremail.toLowerCase() !== userEmail.toLowerCase())) return false;
    if (searchTerm) {
      const lowerCaseSearchTerm = searchTerm.toLowerCase();
      const searchableHeaders = ['Main Task ID', 'Country', 'Account Name', 'Case Title', 'Category', 'Provider Id', 'Useremail'];
      if (!searchableHeaders.some(h => record[h] && String(record[h]).toLowerCase().includes(lowerCaseSearchTerm))) return false;
    }
    return true;
  });

  // Sort and paginate
  filteredRecords.sort((a, b) => new Date(b['Menu Request Sent Date'] || 0) - new Date(a['Menu Request Sent Date'] || 0));
  const paginatedRecords = filteredRecords.slice(offset, offset + limit);

  // Serialize final output for the client
  return paginatedRecords.map(record => {
    const newRecord = {};
    for (const key in record) {
      if (record[key] instanceof Date) { newRecord[key] = record[key].toISOString(); }
      else { newRecord[key] = record[key]; }
    }
    return newRecord;
  });
}

/**
 * Updates a specific case in the AvailableCases sheet.
 * Applies specific number formatting for dates and durations.
 */
function updateCaseData(caseId, updatedData) {
  try {
    if (!caseId || !updatedData) {
      throw new Error("Case ID or update data is missing.");
    }

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
    if (!sheet) throw new Error(`Sheet '${CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES}' not found.`);

    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    const headers = values.shift();
    const caseIdColumnIndex = headers.indexOf('Main Task ID');

    if (caseIdColumnIndex === -1) {
      throw new Error("'Main Task ID' column not found.");
    }

    let rowNumberToUpdate = -1;
    for (let i = 0; i < values.length; i++) {
      if (values[i][caseIdColumnIndex] == caseId) {
        rowNumberToUpdate = i + 2; // +1 for header offset, +1 for 1-based indexing
        break;
      }
    }

    if (rowNumberToUpdate === -1) {
      throw new Error(`Case with ID '${caseId}' not found.`);
    }

    const dateTimeHeaders = ['Main Task Start Date/Time', 'Main Task End Date/Time', 'Salesforce Updated time', 'Date stamp', 'Menu Request Sent Date'];
    const durationHeaders = ['Stored Escalation Duration', 'Stored Pause Duration', 'Stored Agent Handling Time'];

    for (const header of Object.keys(updatedData)) {
      const colIndex = headers.indexOf(header);
      if (colIndex !== -1) {
        let value = updatedData[header];
        const cell = sheet.getRange(rowNumberToUpdate, colIndex + 1);

        if (dateTimeHeaders.includes(header) && value) {
            cell.setValue(new Date(value)).setNumberFormat("MM-dd-yyyy HH:mm:ss");
        } else if (durationHeaders.includes(header) && (typeof value === 'number' || !isNaN(value))) {
            cell.setValue(value).setNumberFormat("HH:mm:ss");
        } else {
            cell.setValue(value);
        }
      }
    }

    return `Case ${caseId} updated successfully.`;

  } catch (e) {
    Logger.log("Error in updateCaseData: " + e.toString() + " Stack: " + e.stack);
    throw new Error("Failed to update case. " + e.message);
  }
}

/**
 * Fetches all related log entries for a given Case ID from multiple log sheets.
 * @param {string} caseId The Main Task ID to search for.
 * @returns {object} An object containing arrays of logs for each type.
 */
function getLogsForCase(caseId) {
  if (!caseId) {
    return { escalationLogs: [], pausingLogs: [], cooperationLogs: [] };
  }

  try {
    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);

    // Helper function to reduce redundant code
    const fetchLogData = (sheetName, ...relatedIdColumnNames) => {
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet || sheet.getLastRow() < 2) return [];

        const data = sheet.getDataRange().getValues();
        const headers = data.shift();
        let relatedIdIndex = -1;

        // Find the first matching column name
        for (const colName of relatedIdColumnNames) {
            relatedIdIndex = headers.indexOf(colName);
            if (relatedIdIndex !== -1) break;
        }

        if (relatedIdIndex === -1) {
            Logger.log(`Warning: None of the potential related ID columns (${relatedIdColumnNames.join(", ")}) were found in sheet "${sheetName}".`);
            return [];
        }

        const logs = [];
        data.forEach(row => {
            if (String(row[relatedIdIndex]).trim() === String(caseId).trim()) {
                let record = {};
                headers.forEach((header, i) => {
                    record[header] = row[i] instanceof Date ? row[i].toISOString() : row[i];
                });
                logs.push(record);
            }
        });
        return logs;
    };

    // Use the flexible helper function with multiple possible column names
    const escalationLogs = fetchLogData(CONFIG.PRODUCTION.SHEETS.ESCALATION_LOGS, "Related Case ID", "Main Task ID", "Case ID");
    const pausingLogs = fetchLogData(CONFIG.PRODUCTION.SHEETS.PAUSING_LOGS, "Related Case ID", "Main Task ID", "Case ID");
    const cooperationLogs = fetchLogData(CONFIG.PRODUCTION.SHEETS.COOPERATION_LOGS, "Related Case ID", "Main Task ID", "Case ID");

    return {
      escalationLogs: escalationLogs,
      pausingLogs: pausingLogs,
      cooperationLogs: cooperationLogs
    };

  } catch(e) {
    Logger.log(`Error in getLogsForCase for ID ${caseId}: ${e.toString()}`);
    return { error: e.message };
  }
}

/**
 * Updates a single log entry in a specified log sheet.
 * @param {string} logId The unique ID of the log entry to update.
 * @param {string} sheetName The name of the sheet to update (e.g., "Escalation Logs").
 * @param {string} primaryKeyColumnName The name of the primary key column (e.g., "Log ID").
 * @param {object} updatedData The object of key-value pairs to update.
 * @returns {string} A success message.
 */
function updateLogData(logId, sheetName, primaryKeyColumnName, updatedData) {
  try {
    if (!logId || !sheetName || !primaryKeyColumnName || !updatedData) {
      throw new Error("Required parameters are missing for updating log data.");
    }

    const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) throw new Error(`Sheet "${sheetName}" not found.`);

    const data = sheet.getDataRange().getValues();
    const headers = data.shift();
    const pkIndex = headers.indexOf(primaryKeyColumnName);

    if (pkIndex === -1) {
      throw new Error(`Primary key column "${primaryKeyColumnName}" not found in sheet "${sheetName}".`);
    }

    let rowIndexToUpdate = -1;
    for (let i = 0; i < data.length; i++) {
      if (String(data[i][pkIndex]).trim() === String(logId).trim()) {
        rowIndexToUpdate = i + 2; // +1 for header offset, +1 for 1-based indexing
        break;
      }
    }

    if (rowIndexToUpdate === -1) {
      throw new Error(`Log entry with ID '${logId}' not found in "${sheetName}".`);
    }

    // Update each cell specified in the updatedData object
    for (const header of Object.keys(updatedData)) {
      const colIndex = headers.indexOf(header);
      if (colIndex !== -1) {
        let value = updatedData[header];
        // If the value is a date string, convert it back to a Date object
        if (typeof value === 'string' && value.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)) {
           value = new Date(value);
        }
        sheet.getRange(rowIndexToUpdate, colIndex + 1).setValue(value);
      }
    }

    return `Log ${logId} in ${sheetName} updated successfully.`;

  } catch (e) {
    Logger.log(`Error in updateLogData: ${e.toString()}`);
    throw new Error(`Failed to update log: ${e.message}`);
  }
}


/**
 * Creates a new Google Sheet with a custom name, specific columns, and formatting.
 * @param {Array<Object>} data An array of objects representing the full data.
 * @param {Array<string>} headers The specific column headers to be exported.
 * @param {string} fileName The desired name for the new spreadsheet.
 * @returns {string} The URL of the newly created spreadsheet.
 */
function createSheetWithData(data, headers, fileName) {
  if (!data || !Array.isArray(data) || data.length === 0) {
    throw new Error("No data provided to create the sheet.");
  }
  if (!headers || !Array.isArray(headers) || headers.length === 0) {
    throw new Error("No column headers were specified for the export.");
  }

  try {
    // THIS LINE IS MODIFIED - It now uses the filename from the browser, with a fallback.
    const spreadsheetName = fileName || `Drill-down Export - ${new Date().toLocaleString()}`;

    const newSs = SpreadsheetApp.create(spreadsheetName);
    const sheet = newSs.getSheets()[0];
    sheet.setName("Exported Data");

    const rows = data.map(obj => headers.map(header => obj[header]));
    const outputData = [headers, ...rows];

    sheet.getRange(1, 1, outputData.length, headers.length).setValues(outputData);

    const durationColIndex = headers.indexOf('Stored Agent Handling Time');
    if (durationColIndex !== -1) {
      const durationRange = sheet.getRange(2, durationColIndex + 1, sheet.getLastRow() - 1, 1);
      durationRange.setNumberFormat("[h]:mm:ss");
    }

    headers.forEach((_, i) => {
      sheet.autoResizeColumn(i + 1);
    });

    sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold");

    return newSs.getUrl();

  } catch (e) {
    Logger.log(`Error in createSheetWithData: ${e.toString()}`);
    throw new Error("Failed to create the spreadsheet. " + e.message);
  }
}

// =================================================================================
// --- CASE ACTION FUNCTIONS ---
// =================================================================================

function updateCaseStatus(caseId, newStatus) {
    try {
        if (!caseId || !newStatus) {
            throw new Error("Case ID or new status is missing.");
        }

        const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
        const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
        if (!sheet) throw new Error("AvailableCases sheet not found.");

        const dataRange = sheet.getDataRange();
        const values = dataRange.getValues();
        const headers = values.shift();
        const caseIdColumnIndex = headers.indexOf('Main Task ID');
        const statusColumnIndex = headers.indexOf('Status');

        if (caseIdColumnIndex === -1) throw new Error("'Main Task ID' column not found.");
        if (statusColumnIndex === -1) throw new Error("'Status' column not found.");

        let rowNumberToUpdate = -1;
        for (let i = 0; i < values.length; i++) {
            if (values[i][caseIdColumnIndex] == caseId) {
                rowNumberToUpdate = i + 2; // +1 for header offset, +1 for 1-based indexing
                break;
            }
        }

        if (rowNumberToUpdate === -1) throw new Error(`Case with ID '${caseId}' not found.`);

        sheet.getRange(rowNumberToUpdate, statusColumnIndex + 1).setValue(newStatus);
        return `Case ${caseId}: Status updated successfully to ${newStatus}.`;

    } catch (e) {
        Logger.log(`Error in updateCaseStatus: ${e.toString()}`);
        throw new Error(`Failed to update status. ${e.message}`);
    }
}

function updateCaseField(caseId, fieldName, value) {
    try {
        if (!caseId || !fieldName) {
            throw new Error("Case ID or field name is missing.");
        }

        const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
        const sheet = ss.getSheetByName(CONFIG.PRODUCTION.SHEETS.AVAILABLE_CASES);
        if (!sheet) throw new Error("AvailableCases sheet not found.");

        const dataRange = sheet.getDataRange();
        const values = dataRange.getValues();
        const headers = values.shift();
        const caseIdColumnIndex = headers.indexOf('Main Task ID');
        const fieldColumnIndex = headers.indexOf(fieldName);

        if (caseIdColumnIndex === -1) throw new Error("'Main Task ID' column not found.");
        if (fieldColumnIndex === -1) throw new Error(`'${fieldName}' column not found.`);

        let rowNumberToUpdate = -1;
        for (let i = 0; i < values.length; i++) {
            if (values[i][caseIdColumnIndex] == caseId) {
                rowNumberToUpdate = i + 2; // +1 for header offset, +1 for 1-based indexing
                break;
            }
        }

        if (rowNumberToUpdate === -1) throw new Error(`Case with ID '${caseId}' not found.`);

        sheet.getRange(rowNumberToUpdate, fieldColumnIndex + 1).setValue(value);
        return `Case ${caseId}: ${fieldName} updated successfully.`;

    } catch (e) {
        Logger.log(`Error in updateCaseField: ${e.toString()}`);
        throw new Error(`Failed to update ${fieldName}. ${e.message}`);
    }
}

function createNewLogEntry(sheetName, logData) {
    try {
        if (!sheetName || !logData) {
            throw new Error("Sheet name or log data is missing.");
        }
        const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet) throw new Error(`Sheet "${sheetName}" not found.`);

        const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
        const newRow = headers.map(header => logData[header] || null);

        sheet.appendRow(newRow);
        return `New log entry created in ${sheetName}.`;
    } catch (e) {
        Logger.log(`Error in createNewLogEntry: ${e.toString()}`);
        throw new Error(`Failed to create log entry. ${e.message}`);
    }
}

function endOpenLogEntry(sheetName, caseId, endColName, relatedIdColName) {
    try {
        const ss = SpreadsheetApp.openById(CONFIG.PRODUCTION.ID);
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet) throw new Error(`Sheet "${sheetName}" not found.`);

        const data = sheet.getDataRange().getValues();
        const headers = data.shift();
        const idIndex = headers.indexOf(relatedIdColName);
        const endIndex = headers.indexOf(endColName);

        if (idIndex === -1 || endIndex === -1) {
            throw new Error(`Required columns not found in "${sheetName}". Check sheet configuration.`);
        }

        // Iterate backwards to find the most recent open log for the case
        for (let i = data.length - 1; i >= 0; i--) {
            const row = data[i];
            if (String(row[idIndex]).trim() === String(caseId).trim() && !row[endIndex]) {
                sheet.getRange(i + 2, endIndex + 1).setValue(new Date());
                return `Log entry for case ${caseId} in ${sheetName} has been closed.`;
            }
        }
        throw new Error(`No open log entry found for case ${caseId} in ${sheetName}.`);

    } catch (e) {
        Logger.log(`Error in endOpenLogEntry: ${e.toString()}`);
        throw new Error(`Failed to end log entry. ${e.message}`);
    }
}


function claimCase(caseId) {
    const userEmail = Session.getActiveUser().getEmail();
    updateCaseStatus(caseId, 'In Progress');
    return updateCaseField(caseId, 'Useremail', userEmail);
}

function pauseCase(caseId) {
    updateCaseStatus(caseId, 'Task Paused');
    const userEmail = Session.getActiveUser().getEmail();
    const logData = {
        'ID': `${caseId}_${new Date().getTime()}`,
        'Related Case ID': caseId,
        'Pause Start Time': new Date(),
        'User Email': userEmail
    };
    return createNewLogEntry(CONFIG.PRODUCTION.SHEETS.PAUSING_LOGS, logData);
}

function unpauseCase(caseId) {
    updateCaseStatus(caseId, 'In Progress');
    return endOpenLogEntry(CONFIG.PRODUCTION.SHEETS.PAUSING_LOGS, caseId, 'Paused End Time', 'Related Case ID');
}

function escalateCase(caseId) {
    updateCaseStatus(caseId, 'Escalated');
    const userEmail = Session.getActiveUser().getEmail();
    const logData = {
        'Log ID': `${caseId}_${new Date().getTime()}`,
        'Related Case ID': caseId,
        'Escalation Start Time': new Date(),
        'User Email': userEmail
    };
    return createNewLogEntry(CONFIG.PRODUCTION.SHEETS.ESCALATION_LOGS, logData);
}

function deEscalateCase(caseId) {
    updateCaseStatus(caseId, 'In Progress');
    return endOpenLogEntry(CONFIG.PRODUCTION.SHEETS.ESCALATION_LOGS, caseId, 'Escalated End Time', 'Related Case ID');
}

function endCase(caseId) {
    updateCaseStatus(caseId, 'Completed');
    return updateCaseField(caseId, 'Main Task End Date/Time', new Date());
}

/**
 * A reusable helper function to get a map of open logs from a specified log sheet.
 * @param {Spreadsheet} ss The spreadsheet object.
 * @param {string} sheetName The name of the log sheet.
 * @param {string} relatedIdCol The name of the column containing the related case ID.
 * @param {string} startCol The name of the start time column.
 * @param {string} endCol The name of the end time column.
 * @returns {Map<string, Date>} A map where keys are case IDs and values are start times.
 */
function getOpenLogs_(ss, sheetName, relatedIdCol, startCol, endCol) {
  const openLogs = new Map();
  const logSheet = ss.getSheetByName(sheetName);
  if (!logSheet) {
    Logger.log(`Warning: Log sheet "${sheetName}" not found.`);
    return openLogs;
  }
  const logData = logSheet.getDataRange().getValues();
  const headers = logData.shift();
  const idIndex = headers.indexOf(relatedIdCol);
  const startIndex = headers.indexOf(startCol);
  const endIndex = headers.indexOf(endCol);

  if ([idIndex, startIndex, endIndex].includes(-1)) {
    Logger.log(`Warning: Required columns not found in "${sheetName}".`);
    return openLogs;
  }

  logData.forEach(row => {
    const caseId = row[idIndex];
    const startTime = row[startIndex];
    const endTime = row[endIndex];
    if (caseId && startTime && !endTime) {
      openLogs.set(String(caseId).trim(), startTime);
    }
  });
  return openLogs;
}
